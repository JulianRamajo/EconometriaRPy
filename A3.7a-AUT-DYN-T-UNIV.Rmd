---
title: 'TEMA 3: Autocorrelación y modelos dinámicos'
author:
  name: Julián Ramajo, ramajo@unex.es
  affiliation: GRADO EN ESTADÍSTICA | ECONOMETRIA (502243)
subtitle: 'Aplicación 3.7.a: Tipos de interés en España en la década de 1980'
output:
  html_document:
    theme: journal
    highlight: haddock
    toc: yes
    toc_depth: 2
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
---

# Objetivo

En esta aplicación se estimará un modelo con autocorrelación en los errores y se propondrán soluciones al problema.

# Código R

```{r, message=FALSE}
# Lectura de librerías
library(tidyverse)
library(dynlm)
library(car)
library(lmtest)
library(sandwich)
library(orcutt)
# Lectura de datos
TIPOS_INT_ESP <- read_delim("TIPOS_INT_ESP.csv", delim = ";")
str(TIPOS_INT_ESP)
head(TIPOS_INT_ESP)
# Gráfica de las series temporales
ggplot(TIPOS_INT_ESP,aes(date,R3M)) +
  geom_line(color="blue") +
  geom_line(aes(date,RD),color="orange") +
  geom_line(aes(date,RL),color="green") +
  xlab("") + ylab("Tipos de interés")
# Asignación del formata trimestral
TIPOS_ESP_ts <- ts(TIPOS_INT_ESP[,2:4], start=c(1982,1), end = c(1990,3), frequency = 4)
plot(TIPOS_ESP_ts)
# Modelo de Klein-Monti (estático)
summary(lm_KM <- lm(RL ~ R3M + RD, data=TIPOS_ESP_ts))
# Librería dynlm
summary(dynlm_KM_0 <- dynlm(RL ~ R3M + RD, data=TIPOS_ESP_ts)) # Especificación ARDL(0,0,0) 
# Contrastes de correlación en los errores (autocorrelación)
# Errores estimados del modelo
resid <-residuals(dynlm_KM_0)
plot(resid)
abline(h=0, lty=2)
# Correlograma de los residuos
corr <- acf(resid)
corr$acf[2:10]
# Test de Durbin-Watson
dwtest(dynlm_KM_0, alternative = "two.sided")
dwtest(dynlm_KM_0, alternative = "greater")
# Test de Breusch-Godfrey
bgtest(dynlm_KM_0, order=1, type="Chisq", fill=0)
# Corrección de la autocorrelación: MCO corregidos, MCG-AR, modelos dinámicos del tipo ARDL
# MCO corregidos: errores estándar robustos, HAC (Newey-West)
summary(dynlm_KM_0 <- dynlm(RL ~ R3M + RD, data=TIPOS_ESP_ts), vcov.=vcovHAC(dynlm_KM_0))
# Mínimos cuadrados generalizados (MCG): errores AR(1)
cochrane.orcutt(dynlm_KM_0)
# Modelo dinámico ARDL(1,1,1) 
summary(dynlm_KM_1 <- dynlm(RL ~ L(RL, 1:1) + L(R3M, 0:1) + L(RD, 0:1), data=TIPOS_ESP_ts))
# Comparación de modelos
compareCoefs(dynlm_KM_0,dynlm_KM_1)
# Estimación de efectos parciales
# Efectos a corto y largo plazo
library(nlWaldTest)
# Modelo estático (c.p=l.p)
nlConfint(dynlm_KM_0, c("b[2]","b[3]"))
nlWaldtest(dynlm_KM_0, "b[2]")
nlWaldtest(dynlm_KM_0, "b[3]")
# Modelo dinámico
# Corto plazo
nlConfint(dynlm_KM_1, c("b[3]","b[5]"))
nlWaldtest(dynlm_KM_1, "b[3]")
nlWaldtest(dynlm_KM_1, "b[5]")
# Largo plazo
nlConfint(dynlm_KM_1, c("(b[3]+b[4])/(1-b[2])","(b[5]+b[6])/(1-b[2])"))
nlWaldtest(dynlm_KM_1, "(b[3]+b[4])/(1-b[2])")
nlWaldtest(dynlm_KM_1, "(b[5]+b[6])/(1-b[2])")
```

# Código Python

```{python, message=FALSE}
# Lectura de librerías
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf
import statsmodels.stats.api as sms
import matplotlib.pyplot as plt
from statsmodels.graphics import tsaplots
import statsmodels.stats.diagnostic as smsdiag
from statsmodels.compat import lzip
# Lectura de datos y asignación del índice temporal
TIPOS_INT_ESP = pd.read_csv("TIPOS_INT_ESP.csv", sep=";", parse_dates=['date'], index_col='date')
TIPOS_INT_ESP.info()
TIPOS_INT_ESP.head()
TIPOS_INT_ESP.index
# Gráfica de las series temporales
plt.figure(1)
fig, ax = plt.subplots()
TIPOS_INT_ESP.plot(ax=ax)
plt.legend(['R3M','RD','RL']); plt.xlabel(''); plt.ylabel('Tipos de interés')
plt.show()
# Asignación del formato trimestral
TIPOS_ESP_ts = pd.read_csv("TIPOS_INT_ESP.csv", sep=";").iloc[:,1:]
date = pd.date_range(start = '1982', periods = len(TIPOS_ESP_ts.index), freq = 'QS')
TIPOS_ESP_ts.index = date
TIPOS_ESP_ts.info()
TIPOS_ESP_ts.head()
TIPOS_ESP_ts.index
plt.figure(3)
fig, ax = plt.subplots(3, 1, sharex = True)
ax[0].plot(TIPOS_ESP_ts.R3M)
ax[0].set_ylabel('R3M')
ax[1].plot(TIPOS_ESP_ts.RD)
ax[1].set_ylabel('RD')
ax[2].plot(TIPOS_ESP_ts.RL)
ax[2].set_ylabel('RL')
plt.show()
# Modelo de Klein-Monti estático
model = smf.ols(formula = "RL ~ R3M + RD", data = TIPOS_ESP_ts)
lm_KM = model.fit()
print(lm_KM.summary())
# Contrastes de correlación en los errores (autocorrelación)
# Errores estimados (residuos)
residuos = lm_KM.resid
plt.figure(6)
plt.plot(residuos, label='Residuos')
plt.xlabel('Date')
plt.legend()
plt.show()
# Correlograma de los residuos
r = sm.tsa.stattools.acf(residuos, nlags=9, fft=True)
plt.figure(7)
fig, ax = plt.subplots()
tsaplots.plot_acf(residuos, lags=15, alpha=0.05, zero=False, vlines_kwargs={"colors":'black'}, color='black', title='', ax=ax, auto_ylims=True)
plt.show()
print(r)
# Test de Durbin-Watson
sms.durbin_watson(residuos).round(5)
# Test de Breusch-Godfrey
name = ['LM statistic', 'Chi^2 p-val', 'F statistic', 'F p-val']
BG_test = smsdiag.acorr_breusch_godfrey(lm_KM,1)
lzip(name, BG_test)
# Corrección de la autocorrelación: MCO corregidos, MCG-AR, modelos dinámicos del tipo ARDL
# MCO corregidos: errores estándar robustos
# Corrección de la matriz de covarianzas: estimador de Newey-West (si maxlags=0 -> HAC=HC1)
lm_KM_HAC = smf.ols(formula = "RL ~ R3M + RD", data = TIPOS_ESP_ts).fit(cov_type='HAC', cov_kwds={'maxlags':6,'use_correction':True})
print(lm_KM_HAC.summary())
# Modelo de Klein-Monti dinámico 
# Especificación ARDL(1,1,1) 
model = smf.ols(formula = "RL ~ RL.shift(1) + R3M + R3M.shift(1) + RD + RD.shift(1)", data = TIPOS_ESP_ts)
lm_KM_dyn = model.fit()
print(lm_KM_dyn.summary())
b = lm_KM_dyn.params[1:]
# Multiplicadores de corto plazo
b[1].round(3) ; b[3].round(3)
# Multiplicadores de largo plazo
b_lr_R3M = (b[1]+b[2])/(1-b[0])
b_lr_R3M.round(3)
b_lr_RD = (b[3]+b[4])/(1-b[0])
b_lr_RD.round(3)
# Contrastes
H_0_b1 = '(R3M = 0)'
W_test = lm_KM_dyn.wald_test(H_0_b1, use_f = False, scalar = True)
W_test
H_0_b3 = '(RD = 0)'
W_test = lm_KM_dyn.wald_test(H_0_b3, use_f = False, scalar = True)
W_test
```

