---
engine: knitr
excerpt: ""
draft: false
format: 
  html:
    theme: simplex
    self-contained: true
    max-width: 1920px
    code-fold: show
    code-tools: true
    highlight-style: atom-one-dark
    code-block-bg: "#282c34"
---

```{css, echo = FALSE}
.justify { text-align: justify !important }
```

::: justify
# Aplicación 1.1.a: Gestión y representación gráfica de datos: datos ordenados ('*tidy data*') {.unnumbered}

## Gramática básica del *tidyverse* {.unnumbered}

En esta aplicación se pondrán ejemplos básicos en R y Python usando la "filosofía *tidyverse*", una forma de trabajar dentro de cada lenguaje con el objetivo de estructurar los datos originales para un tratamiento estadístico posterior:

*"A grandes rasgos, el tidyverse es un lenguaje para resolver los retos de la ciencia de datos \[...\]. Su objetivo principal es facilitar una conversación entre un humano y un ordenador acerca de los datos. De forma menos abstracta, el tidyverse es una colección de \[...\] librerías que comparten una filosofía de diseño de alto nivel y unas estructuras gramatical y de datos de bajo nivel, de modo que aprender una librería facilita el aprendizaje de la siguiente."* (Traducido al español de Wickham et al., 2019)
:::

## Código R {.unnumbered}

::: justify
En las siguientes páginas web se pueden encontrar los detalles sobre la gestión (limpieza y preparación) '*a la tidyverse'* de datos y gráficos en R:
:::

1.  Datos ordenados: <https://tidyr.tidyverse.org/articles/tidy-data.html>

2.  La macro-librería `tidyverse` en R:

    <https://www.tidyverse.org/>

    <https://tidyverse.tidyverse.org/articles/paper.html>

3.  Varias lecciones para entender cómo funciona el tidyverse en R:

    <https://education.rstudio.com/blog/2020/07/teaching-the-tidyverse-in-2020-part-1-getting-started/>

    <https://education.rstudio.com/blog/2020/07/teaching-the-tidyverse-in-2020-part-2-data-visualisation/>

    <https://education.rstudio.com/blog/2020/07/teaching-the-tidyverse-in-2020-part-3-data-wrangling-and-tidying/>

    <https://education.rstudio.com/blog/2020/07/teaching-the-tidyverse-in-2020-part-4-when-to-purrr/>

::: justify
En términos generales, para aprender cómo hacer "ciencia de datos" con R se puede consultar el libro de de Wickham y Grolemund: <https://r4ds.hadley.nz/> (la versión en español del libro está disponible en <https://es.r4ds.hadley.nz/>).

Sobre los datos utilizados en esta aplicación:

1.  *Gapminder* (<https://www.gapminder.org/fw/world-health-chart/>): los datos por países se han extraído de la base de datos del Banco Mundial (<https://data.worldbank.org/>), usando la librería `WDI` (<https://vincentarelbundock.github.io/WDI/index.html>).

2.  *NYC_Flights_2013* (<https://github.com/tidyverse/nycflights13>)
:::

```{r}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
library(tidyverse)
tidyverse_packages()
# Estructura de la macro-librería 'tidyverse'
library(deepdep)
dep_tidyverse <- deepdep("tidyverse", depth = 1)
plot_dependencies(dep_tidyverse, "circular")
# Lectura de datos
# (https://es.r4ds.hadley.nz/10-tibble.html)
# (https://es.r4ds.hadley.nz/11-import.html)
gapminder <- read_csv("data/GAPMINDER.csv")
dim(gapminder)
class(gapminder)
# Manejo y transformación de datos
# (https://es.r4ds.hadley.nz/05-transform.html)
#
# Cambio de nombres de variables
gapminder <- gapminder %>% 
  rename(year = date, 
         gdpPercap = NY.GDP.PCAP.CD, 
         lifeExp = SP.DYN.LE00.IN, 
         pop = SP.POP.TOTL)
# Datos iniciales y finales
head(gapminder)
tail(gapminder)
# Librería dplyr (https://dplyr.tidyverse.org/) 
# y 'tuberías' (https://es.r4ds.hadley.nz/18-pipes.html)
#
# "Verbos" de dplyr 
# select
gapminder_selected <- select(gapminder, year, country, pop, gdpPercap)
# filter
gapminder_filtered <- filter(gapminder_selected, year >= 1980)
# mutate
gapminder_mutated <- mutate(gapminder_filtered, GDP = gdpPercap*pop)
# group_by
gapminder_grouped <- group_by(gapminder_mutated, country)
# summarise
gapminder_summarised <- summarise(gapminder_grouped, 
                                  GDP_avg = mean(GDP, na.rm = TRUE))
# arrange
gapminder_arranged_ascending <- arrange(gapminder_summarised, GDP_avg)
gapminder_arranged_ascending
gapminder_arranged_descending <- arrange(gapminder_summarised, -GDP_avg)
gapminder_arranged_descending
# Operador tubería del tidyverse: encadenamientos con '%>%'
# (tubería nativa de R: |> )
AVG_GDP <- 
  gapminder %>% 
  select(year, country, pop, gdpPercap) %>% 
  filter(year>=1980) %>% 
  mutate(GDP=gdpPercap*pop) %>% 
  group_by(country) %>% 
  summarise(GDP_avg=mean(GDP, na.rm = TRUE)) %>% 
  arrange(-GDP_avg) %>% 
  na.omit()
head(AVG_GDP,10)
tail(AVG_GDP,10)

COUNT_cntr <- 
  gapminder %>%
  select(year, region, country) %>% 
  filter(year>=1980) %>% 
  group_by(region) %>%
  summarise(cntr_distinct = n_distinct(country))
COUNT_cntr

AVG_lifeExp <- 
  gapminder %>%
  select(year, lifeExp) %>% 
  filter(year>=1980) %>% 
  group_by(year) %>%
  summarise(lifeExp_avg=mean(lifeExp, , na.rm = TRUE)) 
AVG_lifeExp

AVG_lifeExp_gdpPercap <- 
  gapminder %>% 
   select(year, region, lifeExp, gdpPercap) %>% 
  filter(year>=1980) %>% 
  group_by(year,region) %>%
  summarise(lifeExp_avg=mean(lifeExp, , na.rm = TRUE),
            gdpPercap_avg=mean(gdpPercap, , na.rm = TRUE)) 
AVG_lifeExp_gdpPercap
# Gramática de gráficas (ggplot2) [https://ggplot2.tidyverse.org/]
# (https://es.r4ds.hadley.nz/03-visualize.html)
#
# Gráfica 0: diagrama de puntos básico
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + 
  geom_point(alpha = 0.7)
# Gráfica 0 plus: con ajuste no paramétrico
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + 
  geom_point(alpha = 0.2) + geom_smooth(method = "loess")
# Gráfica 1: colores por regiones
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + 
  geom_point(aes(col = region), alpha = 0.3)
# Gráfica 2: colores por regiones y tamaño por población
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + 
  geom_point(aes(size = pop, col = region), alpha = 0.3)
# Gráfica 3: colores por regiones y tamaño por población (esc. log)
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
    geom_point(aes(size = pop, col = region), alpha = 0.3) +
    scale_x_log10(labels = scales::dollar) + # Esc.log. eje X, unidades $
    labs(x = "PIB per capita (log)", y = "Experanza de vida al nacer") + 
    theme_minimal() # Tema b&w
# Gráfica 4: burbujas de Hans-Rosling 
# (https://www.gapminder.org/fw/world-health-chart/)
library(viridis)
library(gganimate)
ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
    geom_point(alpha = 0.7, show.legend = FALSE) +
    scale_x_log10(labels = scales::dollar) +
    labs(title = 'Año: {frame_time}', x = 'PIB per capita (log)', 
         y = 'Experanza de vida al nacer') +
    transition_time(year) +
    ease_aes('linear')
# Gráfica 4 plus: animación con cambio de la relación por años
ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
  geom_point(alpha = 0.7, show.legend = FALSE) +
  scale_x_log10(labels = scales::dollar) +
  facet_wrap(~region) +
  labs(title = 'Año: {frame_time}', x = 'PIB per capita (log)', 
       y = 'Experanza de vida al nacer') +
  transition_time(year) +
  ease_aes('linear')
# Unir, combinar y remodelar ficheros de datos
# (https://es.r4ds.hadley.nz/13-relational-data.html)
#
# Familia de operaciones join:
# `inner_join(df1, df2)`
# `left_join(df1, df2)`
# `right_join(df1, df2)`
# `full_join(df1, df2)`
# `semi_join(df1, df2)`
# `anti_join(df1, df2)`
#
# Lectura de datos
library(nycflights13)
flights 
planes
# Ejemplo de unión (por la izquierda): left_join
# Debe usarse el argumento 'by =' para evitar errores o malas
# asignaciones automáticas. 
# Ejemplos de otras operaciones en pueden encontrarse en:
# https://cran.r-project.org/web/packages/dplyr/vignettes/two-table.html
flights_planes <- left_join(flights, planes, by = "tailnum") %>%
  select(month, day, dep_time, arr_time, 
         carrier, flight, tailnum, model)
flights_planes
```

## Código Python {.unnumbered}

::: justify
En las siguientes páginas web se pueden encontrar los detalles sobre la gestión '*a la tidyverse'* de datos y gráficos en Python:
:::

1.  librería `pandas`:

    <https://pandas.pydata.org/docs/user_guide/index.html>

    <https://wesmckinney.com/book/accessing-data>

    <https://wesmckinney.com/book/data-cleaning>

    <https://wesmckinney.com/book/data-wrangling>

2.  librería `plotnine`: <https://plotnine.readthedocs.io/en/stable/>

::: justify
En términos generales, para aprender cómo hacer "ciencia de datos" con Python se puede consultar el libro de McKinney: <https://wesmckinney.com/book/>.
:::

```{r}
library(reticulate)
```

```{python}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from plotnine import *
# Lectura de datos (reticulate)
gapminder = r.gapminder
gapminder.shape
gapminder.columns
gapminder.info()
# Datos iniciales y finales
gapminder.head()
gapminder.tail()
# Operaciones del tidyverse con Pandas
# select
gapminder_selected = gapminder[['year','country', 'pop', 'gdpPercap']]
# filter
gapminder_filtered = gapminder_selected[(gapminder_selected["year"] >= 1980)]
# mutate
gapminder_filtered['GDP'] = gapminder_filtered['gdpPercap'] * gapminder_filtered['pop']
# groupby
gapminder_grouped = gapminder_filtered.groupby('country')
# summarise
gapminder_summarised = gapminder_grouped['GDP'].mean()
gapminder_summarised = gapminder_summarised.dropna()
# arrange (sort)
gapminder_summarised.sort_values(ascending=False).head(10)
gapminder_summarised.sort_values(ascending=True).head(10)
# Se obtiene el mismo resultado con nlargest y nsmallest
gapminder_summarised.nlargest(10)
gapminder_summarised.nsmallest(10)
# Tuberías en pandas: operaciones encadenadas con '.'
gapminder[(gapminder["year"] >= 1980)].groupby('region')['country'].nunique()
gapminder[(gapminder["year"] >= 1980)].groupby('year')['lifeExp'].mean()
gapminder[(gapminder["year"] >= 1980)].groupby(['year', 'region'])[['lifeExp', 'gdpPercap']].mean()
# Operaciones gráficas del tidyverse con `plotnine`
# Gráfica 0: diagrama de puntos básico
(
    ggplot(gapminder, aes(x='gdpPercap', y='lifeExp'))
    + geom_point(alpha=0.7)
    + labs(x='gdpPercap', y='lifeExp')
)
# Gráfica 0 plus: con ajuste no paramétrico
(
    ggplot(gapminder, aes(x='gdpPercap', y='lifeExp'))
    + geom_point(alpha=0.2) + geom_smooth(method = "loess")
    + labs(x='gdpPercap', y='lifeExp')
)
# Gráfica 1: colores por regiones
(
    ggplot(gapminder, aes(x='gdpPercap', y='lifeExp', color='factor(region)'))
    + geom_point(alpha=0.3)
    +  labs(x='gdpPercap', y='lifeExp')
)
# Gráfica 2: colores por regiones y tamaño por población
(
    ggplot(gapminder, aes(x='gdpPercap', y='lifeExp', color='region', size='pop'))
    + geom_point(alpha=0.3)
    +  labs(x='gdpPercap', y='lifeExp')
)
# Gráfica 3: colores por regiones y tamaño por población (esc. log.)
gapminder['l_gdpPercap']=gapminder['gdpPercap'].map(lambda x:np.log(x))

(
    ggplot(gapminder, aes(x='l_gdpPercap', y='lifeExp', color='region', size='pop'))
    + geom_point(alpha=0.3)
    +  labs(x='PIB per capita (log)', y='Experanza de vida al nacer')
)
# Unir, combinar y remodelar ficheros de datos
# (https://wesmckinney.com/book/data-wrangling)
flights = r.flights 
planes = r.planes
flights_planes = flights.merge(planes, on = 'tailnum', how = 'left')
flights_planes_selected = flights_planes[['month', 'day', 'dep_time', 'arr_time', 'carrier', 'flight', 'tailnum', 'model']]
flights_planes_selected
```

```{python}
# ANEXO: Gramática de datos y tuberías con la librería `siuba`
# (https://siuba.readthedocs.io/en/latest/)
from siuba import *
# Lectura de datos
mtcars = pd.read_csv('data/MTCARS.csv')
mtcars.shape
mtcars.columns
mtcars.info()
mtcars.head()
# arrange, group_by
mtcars_groups = mtcars >> arrange(_.hp) >> group_by(_.cyl)
mtcars_groups
# group_by, filter, summarize, arrange
# and
(mtcars >> filter((_.cyl == 4), (_.gear == 5)))
# or
(mtcars >> filter((_.cyl == 4) | (_.gear == 5)))
# grouped filters, count
(mtcars >> group_by(_.cyl) >> summarize(n = _.cyl.count()))
(mtcars >> count(_.cyl))
(mtcars >> count(_.cyl, _.gear, sort = True))
(mtcars >> count(_.cyl, many_gears = _.gear > 3))
(mtcars >> group_by(_.cyl) >> summarize(n = _.cyl.median()))
(mtcars >> group_by(_.cyl) >> filter(_.hp > _.hp.median()))
# arrange, group_by, filter
from siuba.dply.vector import row_number
(mtcars >> arrange(_.hp) >> group_by(_.cyl) >> filter(row_number(_) <= 2))
# lag, led
from siuba.dply.vector import lag # o led
(mtcars >> arrange(_.hp) >> filter(_.hp - lag(_.hp) > 50))
# arrange, select, rename
small_mtcars = mtcars >> select(_.cyl, _.mpg, _.hp)
small_mtcars
# ordenar filas con una variable
(small_mtcars >> arrange(_.hp)) # ascendente
(small_mtcars >> arrange(-_.hp)) # descendente
# ordenar filas usando varias varialbes
(small_mtcars >> arrange(_.cyl, _.mpg))
# ordenar por hp/cyl (horsepower per cylinder)
(small_mtcars >> arrange(_.hp / _.cyl))
# seleccionar variables 
# equivalente: mtcars >> select(1, 2) , mtcars >> select("mpg", "cyl")
(mtcars >> select(_.mpg, _.cyl))
# excluir columnas
(mtcars >> select(-_.mpg, -_.cyl))
(mtcars >> select(-_.model))
# seleccionar y renombrar
(mtcars >> select(_.miles_per_gallon == _.mpg, _.number_of_cylinders == _.cyl))
# seleccionar columnas (adjacentes)
(mtcars >> select(_["mpg": "hp"])) # equivalente: mtcars >> select(_[1:3])
# excluir columnas seleccionadas
(mtcars >> select(-_["mpg": "hp"]))
# renombrar
mtcars >> rename(transm = "am")
# mutate
# nuevas columnas
(small_mtcars >> mutate(hp_per_cyl = _.hp / _.cyl))
(small_mtcars >> mutate(hp_per_cyl = _.hp / _.cyl,  diff = _.hp_per_cyl - _.hp_per_cyl.shift(1)))
# mutate, group_by
(small_mtcars >> group_by(_.cyl) >> mutate(hp_mean = _.hp.mean(), demeaned_hp = _.hp - _.hp_mean))
# transmute = mutate + select
(mtcars >> transmute(_.cyl, _.mpg, hp_per_cyl = _.hp / _.cyl))
# summarize
# global
(mtcars >> summarize(avg_mpg = _.mpg.mean()))
# por grupos
(mtcars >> group_by(_.cyl) >> summarize(avg_mpg = _.mpg.mean()))
# filter
high_hp_mtcars = mtcars >> filter(_.hp > _.hp.mean())
high_hp_mtcars
(high_hp_mtcars >> mutate(avg_hp = _.hp.mean()))
# joins
df1 = pd.DataFrame({'id': [1,2], 'x': ['a', 'b']})
df2 = pd.DataFrame({'id': [2,2,3], 'y': ['l', 'm', 'n']})
df1
df2
# inner joins
df1 >> inner_join(_, df2, on = "id")
inner_join(df1, df2, on = "id")
# left joins
left_join(df1, df2, on = "id")
# full join
full_join(df1, df2, on = "id")
# semi join
semi_join(df1, df2, on = "id")

# Siuba + plotnine
(
    ggplot(mtcars, aes(x='disp', y='hp'))
    + geom_point()
    + labs(x='Cilindrada', y='Potencia')
)
(
    ggplot(mtcars, aes(x='disp', y='hp'))
    + geom_point()
    + geom_smooth(method='lm', color = "blue")
    + labs(x='Cilindrada', y='Potencia')
)
(
    ggplot(mtcars, aes(x='disp', y='hp'))
    + geom_point()
    + geom_smooth(color = "blue")
    + labs(x='Cilindrada', y='Potencia')
)
(ggplot(mtcars, aes('disp', 'hp', color='factor(gear)'))
 + geom_point()
 + stat_smooth(method='lm')
 + facet_wrap('~gear'))
(
    ggplot(mtcars, aes(x='disp', y='hp', color='factor(gear)'))
    + geom_point()
    + geom_smooth(method='lm')
    +  labs(x='Cilindrada', y='Potencia')
)
(mtcars
 >> ggplot(aes(x = 'wt', y = 'mpg'))
  + geom_point(aes(color = 'factor(gear)', shape = 'factor(gear)'), size = 3)
  + theme_minimal()
  + labs(title = "Datos mtcars, Motor Trend US magazine (1974)",
        x = "Peso (libras/1000) [US]",
        y = "Millas/galón [US]",
        color = "Número de marchas",
        shape = "Número de marchas"))
```
