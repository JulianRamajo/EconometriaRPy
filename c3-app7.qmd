---
engine: knitr
excerpt: ""
draft: false
format: 
  html:
    theme: simplex
    self-contained: true
    max-width: 1920px
    code-fold: show
    code-tools: true
    highlight-style: atom-one-dark
    code-block-bg: "#282c34"
---

```{css, echo = FALSE}
.justify { text-align: justify !important }
```

::: justify
# Aplicación 3.7 (Autocorrelación y regresiones dinámicas): Modelos ARDL y VAR {.unnumbered}

## Caso univariante (especificación ARDL: Tipos de interés en España en la década de 1980 {.unnumbered}

En esta primera aplicación se estimará un modelo de regresión uniecuacional con autocorrelación en los errores y se propondrán soluciones al problema.
:::

### Código R {.unnumbered}

```{r}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
library(tidyverse)
library(dynlm)
library(car)
library(lmtest)
library(sandwich)
library(orcutt)
# Lectura de datos
TIPOS_INT_ESP <- read_delim("data/TIPOS_INT_ESP.csv", delim = ";")
str(TIPOS_INT_ESP)
head(TIPOS_INT_ESP)
# Gráfica de las series temporales
ggplot(TIPOS_INT_ESP,aes(date,R3M)) +
  geom_line(color="blue") +
  geom_line(aes(date,RD),color="orange") +
  geom_line(aes(date,RL),color="green") +
  xlab("") + ylab("Tipos de interés")
# Asignación del formata trimestral
TIPOS_ESP_ts <- ts(TIPOS_INT_ESP[,2:4], start=c(1982,1), end = c(1990,3), frequency = 4)
plot(TIPOS_ESP_ts)
# Modelo de Klein-Monti (estático)
summary(lm_KM <- lm(RL ~ R3M + RD, data=TIPOS_ESP_ts))
# Librería dynlm
summary(dynlm_KM_0 <- dynlm(RL ~ R3M + RD, data=TIPOS_ESP_ts)) # Especificación ARDL(0,0,0) 
# Contrastes de correlación en los errores (autocorrelación)
# Errores estimados del modelo
resid <-residuals(dynlm_KM_0)
plot(resid)
abline(h=0, lty=2)
# Correlograma de los residuos
corr <- acf(resid)
corr$acf[2:10]
# Test de Durbin-Watson
dwtest(dynlm_KM_0, alternative = "two.sided")
dwtest(dynlm_KM_0, alternative = "greater")
# Test de Breusch-Godfrey
bgtest(dynlm_KM_0, order=1, type="Chisq", fill=0)
# Corrección de la autocorrelación: MCO corregidos, MCG-AR, modelos dinámicos del tipo ARDL
# MCO corregidos: errores estándar robustos, HAC (Newey-West)
summary(dynlm_KM_0 <- dynlm(RL ~ R3M + RD, data=TIPOS_ESP_ts), vcov.=vcovHAC(dynlm_KM_0))
# Mínimos cuadrados generalizados (MCG): errores AR(1)
cochrane.orcutt(dynlm_KM_0)
# Modelo dinámico ARDL(1,1,1) 
summary(dynlm_KM_1 <- dynlm(RL ~ L(RL, 1:1) + L(R3M, 0:1) + L(RD, 0:1), data=TIPOS_ESP_ts))
# Comparación de modelos
compareCoefs(dynlm_KM_0,dynlm_KM_1)
# Estimación de efectos parciales
# Efectos a corto y largo plazo
library(nlWaldTest)
# Modelo estático (c.p=l.p)
nlConfint(dynlm_KM_0, c("b[2]","b[3]"))
nlWaldtest(dynlm_KM_0, "b[2]")
nlWaldtest(dynlm_KM_0, "b[3]")
# Modelo dinámico
# Corto plazo
nlConfint(dynlm_KM_1, c("b[3]","b[5]"))
nlWaldtest(dynlm_KM_1, "b[3]")
nlWaldtest(dynlm_KM_1, "b[5]")
# Largo plazo
nlConfint(dynlm_KM_1, c("(b[3]+b[4])/(1-b[2])","(b[5]+b[6])/(1-b[2])"))
nlWaldtest(dynlm_KM_1, "(b[3]+b[4])/(1-b[2])")
nlWaldtest(dynlm_KM_1, "(b[5]+b[6])/(1-b[2])")
```

### Código Python {.unnumbered}

```{python}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf
import statsmodels.stats.api as sms
import matplotlib.pyplot as plt
from statsmodels.graphics import tsaplots
import statsmodels.stats.diagnostic as smsdiag
from statsmodels.compat import lzip
# Lectura de datos y asignación del índice temporal
TIPOS_INT_ESP = pd.read_csv("data/TIPOS_INT_ESP.csv", sep=";", parse_dates=['date'], index_col='date')
TIPOS_INT_ESP.info()
TIPOS_INT_ESP.head()
TIPOS_INT_ESP.index
# Gráfica de las series temporales
plt.figure(1)
fig, ax = plt.subplots()
TIPOS_INT_ESP.plot(ax=ax)
plt.legend(['R3M','RD','RL']); plt.xlabel(''); plt.ylabel('Tipos de interés')
plt.show()
# Asignación del formato trimestral
TIPOS_ESP_ts = pd.read_csv("data/TIPOS_INT_ESP.csv", sep=";").iloc[:,1:]
date = pd.date_range(start = '1982', periods = len(TIPOS_ESP_ts.index), freq = 'QS')
TIPOS_ESP_ts.index = date
TIPOS_ESP_ts.info()
TIPOS_ESP_ts.head()
TIPOS_ESP_ts.index
plt.figure(3)
fig, ax = plt.subplots(3, 1, sharex = True)
ax[0].plot(TIPOS_ESP_ts.R3M)
ax[0].set_ylabel('R3M')
ax[1].plot(TIPOS_ESP_ts.RD)
ax[1].set_ylabel('RD')
ax[2].plot(TIPOS_ESP_ts.RL)
ax[2].set_ylabel('RL')
plt.show()
# Modelo de Klein-Monti estático
model = smf.ols(formula = "RL ~ R3M + RD", data = TIPOS_ESP_ts)
lm_KM = model.fit()
print(lm_KM.summary())
# Contrastes de correlación en los errores (autocorrelación)
# Errores estimados (residuos)
residuos = lm_KM.resid
plt.figure(6)
plt.plot(residuos, label='Residuos')
plt.xlabel('Date')
plt.legend()
plt.show()
# Correlograma de los residuos
r = sm.tsa.stattools.acf(residuos, nlags=9, fft=True)
plt.figure(7)
fig, ax = plt.subplots()
tsaplots.plot_acf(residuos, lags=15, alpha=0.05, zero=False, vlines_kwargs={"colors":'black'}, color='black', title='', ax=ax)
plt.show()
print(r)
# Test de Durbin-Watson
sms.durbin_watson(residuos).round(5)
# Test de Breusch-Godfrey
name = ['LM statistic', 'Chi^2 p-val', 'F statistic', 'F p-val']
BG_test = smsdiag.acorr_breusch_godfrey(lm_KM,1)
lzip(name, BG_test)
# Corrección de la autocorrelación: MCO corregidos, MCG-AR, modelos dinámicos del tipo ARDL
# MCO corregidos: errores estándar robustos
# Corrección de la matriz de covarianzas: estimador de Newey-West (si maxlags=0 -> HAC=HC1)
lm_KM_HAC = smf.ols(formula = "RL ~ R3M + RD", data = TIPOS_ESP_ts).fit(cov_type='HAC', cov_kwds={'maxlags':6,'use_correction':True})
print(lm_KM_HAC.summary())
# Modelo de Klein-Monti dinámico 
# Especificación ARDL(1,1,1) 
model = smf.ols(formula = "RL ~ RL.shift(1) + R3M + R3M.shift(1) + RD + RD.shift(1)", data = TIPOS_ESP_ts)
lm_KM_dyn = model.fit()
print(lm_KM_dyn.summary())
b = lm_KM_dyn.params[1:]
# Multiplicadores de corto plazo
b[1].round(3) ; b[3].round(3)
# Multiplicadores de largo plazo
b_lr_R3M = (b[1]+b[2])/(1-b[0])
b_lr_R3M.round(3)
b_lr_RD = (b[3]+b[4])/(1-b[0])
b_lr_RD.round(3)
# Contrastes
H_0_b1 = '(R3M = 0)'
W_test = lm_KM_dyn.wald_test(H_0_b1, use_f = False)
W_test
H_0_b3 = '(RD = 0)'
W_test = lm_KM_dyn.wald_test(H_0_b3, use_f = False)
W_test
```

::: justify
## Caso multivariante (especificación VAR): Evolución temporal de los tipos de cambio {.unnumbered}

En esta segunda aplicación se estimará un modelo vectorial autorregresivo para explicar la evolución en el tiempo de tres tipos de cambio.
:::

### Código R {.unnumbered}

```{r}
#| include: true
#| warning: false
#| message: false

# Lectura de datos
library(readxl)
data <- read_excel("data/TIPOS_CAMB.xls")
data$reur = c(NA,100*diff(log(data$EUR)))
data$rgbp = c(NA,100*diff(log(data$GBP)))
data$rjpy = c(NA,100*diff(log(data$JPY)))
data = data[-1,]
# Modelo VAR
library(vars)
VARselect(data[c("reur","rgbp","rjpy")], lag.max = 10)
VAR(data[c("reur","rgbp","rjpy")],p = 2)
var = VAR(data[c("reur","rgbp","rjpy")],p = 2)
# Análisis de causalidad de Granger
causality(var,cause = c("rgbp","rjpy"))$Granger
causality(var,cause = c("reur","rjpy"))$Granger
causality(var,cause = c("reur","rgbp"))$Granger
# Funciones de respuesta al impulso y de descomposición de la varianza
ir = irf(var,n.ahead = 20)
plot(ir)
vd = fevd(var,n.ahead = 20)
plot(vd)
```

### Código Python {.unnumbered}

```{python}
#| include: true
#| warning: false
#| message: false
# Lectura de librerías
import pandas as pd
import numpy as np
import statsmodels.tsa.api as smt
import matplotlib.pyplot as plt
# Lectura de datos
data = pd.read_excel("data/TIPOS_CAMB.xls", index_col=0)
def LogDiff(x):
    x_diff = 100*np.log(x/x.shift(1))
    x_diff = x_diff.dropna()
    return x_diff
data = pd.DataFrame({'reur':LogDiff(data['EUR']),
                     'rgbp':LogDiff(data['GBP']),
                     'rjpy':LogDiff(data['JPY'])})
# Modelo VAR 
model = smt.VAR(data)
res = model.select_order(maxlags=10)
print(res.summary())
res = model.fit(maxlags=2)
print(res.summary())
# Funciones de respuesta al impulso y de descomposición de la varianza
irf = res.irf(20)
plt.figure(8)
fig = irf.plot()
plt.show()
fevd = res.fevd(20)
plt.figure(9)
fig = fevd.plot()
plt.show()
```
