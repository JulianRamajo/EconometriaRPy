---
engine: knitr
excerpt: ""
draft: false
format: 
  html:
    theme: simplex
    self-contained: true
    max-width: 1920px
    code-fold: show
    code-tools: true
    highlight-style: atom-one-dark
    code-block-bg: "#282c34"
---

```{css, echo = FALSE}
.justify { text-align: justify !important }
```

::: justify
# Aplicación 2.3: Estimación por MCO y contrastes de hipótesis {.unnumbered}

## Modelo CAPM para las acciones del Banco Santander {.unnumbered}

En esta aplicación se estimará una versión simple del [modelo CAPM](https://es.wikipedia.org/wiki/Modelo_de_valoraci%C3%B3n_de_activos_financieros) para las acciones del Banco Santander:

$$erSAN_{t} = \beta_{1} + \beta_{2}\, erIBEX_{t} + e_{t}$$

donde *erSAN* representa el *exceso de rendimiento* de las acciones del Banco Santander, definido como la diferencia entre la rentabilidad de las acciones del banco y la rentabilidad de un activo libre de riesgo, en nuestro caso las letras del tesoro, y *erIBEX* es el exceso de rendimiento del mercado, representado por el índice IBEX35 de la bolsa española.

Como ejercicio, se pueden repetir todos los cálculos de la aplicación para analizar las empresas Telefónica e Inditex, cuyos datos están contenidos en el fichero usado en la aplicación.
:::

## Código R {.unnumbered}

```{r}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
library(tidyverse)
# Lectura de datos
CAPM_ESP <- read_delim("data/CAPM_ESP.csv", delim = ";")
head(CAPM_ESP)
tail(CAPM_ESP)
# Transformación de variables
CAPM_ESP$r_SAN = c(NA,100*diff(log(CAPM_ESP$P_SANTANDER)))
CAPM_ESP$r_IBEX = c(NA,100*diff(log(CAPM_ESP$P_IBEX35)))
CAPM_ESP$r_LT1Y = CAPM_ESP$R_LT1Y/12
CAPM_ESP$er_SAN = CAPM_ESP$r_SAN - CAPM_ESP$r_LT1Y
CAPM_ESP$er_IBEX = CAPM_ESP$r_IBEX - CAPM_ESP$r_LT1Y
# Formato de series temporales
ts_CAPM_ESP <- ts(CAPM_ESP, 
                  start = c(2001,5), 
                  end = c(2018,1), 
                  frequency = 12)
# Algunas gráficas de las variables básicas del modelo
ts.plot(ts_CAPM_ESP[,"P_IBEX35"])
ts.plot(ts_CAPM_ESP[,"P_SANTANDER"])
ts.plot(ts_CAPM_ESP[,"er_SAN"],ts_CAPM_ESP[,"er_IBEX"])
# Modelo CAPM para las acciones del Banco Santander 
CAPM_SANTANDER  <-  lm(er_SAN ~ er_IBEX, data = ts_CAPM_ESP)
summary(CAPM_SANTANDER)
# Intervalos de confianza para los parámetros estructurales del modelo
# Cálculo de forma 'manual'
alpha <- 0.05
df <- df.residual(CAPM_SANTANDER) # grados de libertad
t_c <- qt(1-alpha/2, df)
b1 <- coef(CAPM_SANTANDER)[[1]] # estimación del parámetro beta1
b1
seb1 <- sqrt(vcov(CAPM_SANTANDER)[1,1]) # est. desviación típica beta1
seb1
inf_b1 <- b1-t_c*seb1 # cota inferior
sup_b1 <- b1+t_c*seb1 # cota superior
inf_b1 ; sup_b1
b2 <- coef(CAPM_SANTANDER)[[2]] # estimación del parámetro beta2
b2
seb2 <- sqrt(vcov(CAPM_SANTANDER)[2,2]) # est. desviación típica beta2
seb2
inf_b2 <- b2-t_c*seb2 # cota inferior
sup_b2 <- b2+t_c*seb2 # cota superior
inf_b2 ; sup_b2
# Cálculo automático
confint(CAPM_SANTANDER)
# Ajuste del modelo (R^2) y ANOVA
s_CAPM_SANTANDER <- summary(CAPM_SANTANDER)
print(s_CAPM_SANTANDER)
names(s_CAPM_SANTANDER)
R2 <- s_CAPM_SANTANDER$r.squared
R2
anova(CAPM_SANTANDER)
# Número de obsevaciones
T <- nobs(CAPM_SANTANDER)
T
# Número de parámetros
K <- T-df
K
# Estadístico F de significación global
F_0 <- (R2/(K-1))/((1-R2)/(T-K))
F_0
# Residuos del modelo
res <- s_CAPM_SANTANDER$residuals
res <- ts(res, start=c(2001,5), end = c(2018,1), frequency = 12)
plot(res)
# Histograma de los residuos y comparación con la distribución normal
ehat <- resid(CAPM_SANTANDER)
ebar <- mean(ehat)
sdehat <- sd(ehat)
hist(ehat, col="grey", breaks = 20, freq=FALSE, main="", 
     ylab="density", xlab="ehat")
curve(dnorm(x, ebar, sdehat), col=2, add=TRUE, ylab="density", xlab="ehat")
# Contrastes de hipótesis bilaterales
#
# "Valor alfa" del activo: beta1=0 versus beta1≠0
# Estadístico t
alpha <- 0.05 # nivel de significación
b1 <- coef(CAPM_SANTANDER)[[1]] # estimación del parámetro beta1
b1
seb1 <- sqrt(vcov(CAPM_SANTANDER)[1,1]) # est. desviación típica beta1
seb1
c <- 0
df <- df.residual(CAPM_SANTANDER) # grados de libertad
t_0 <- (b1-c)/seb1 # estadístico t
t_0
# Método del valor crítico
t_c <- qt(1-alpha/2, df) # valor crítico
t_c
# Gráfico de la función de densidad de la distribución t de Student, 
# del valor crítico y del estadístico t_0
curve(dt(x, df), -5, 5, ylab=" ", xlab="t")
abline(v=c(-t_c, t_c, t_0), col=c("red", "red", "blue"), lty=c(2,2,3))
legend("topleft", legend=c("-t_c", "t_c", "t_0"), 
       col=c("red", "red", "blue"), lty=c(2, 2, 3))
# Método del P-valor
p <- 2*(1-pt(abs(t_0), df))
p
# Gráfico de la función de densidad de la distribución t y del estadístico t_0
curve(dt(x, df), -5, 5, ylab=" ", xlab="t")
abline(v=c(t_0), col=c("blue"), lty=c(3))
legend("topleft", legend=c("t_0"), col=c("blue"), lty=c(3))
# Estadístico F
library(car)
H_0 <- "(Intercept) = 0"
linearHypothesis(CAPM_SANTANDER, H_0, test="F")
# Gráfico de la función de densidad de la distribución F de Fisher-Snedecor, 
# del valor crítico y del estadístico F_0
F_0 <- linearHypothesis(CAPM_SANTANDER, H_0, test="F")[2,5] # estadístico F
F_0
F_c <- qf(1-alpha, 1, df) # valor crítico
F_c
curve(df(x, 1, df), 0, 5, ylab=" ", xlab="F")
abline(v=c(F_0,F_c), col=c("blue","red"), lty=c(2,3))
legend("topleft", legend=c("F","Fcr"), col=c("blue","red"), lty=c(2,3))
# "Valor beta" del activo: beta2=1 versus beta2≠1
# Estadístico t
alpha <- 0.05 # nivel de significación
b2 <- coef(CAPM_SANTANDER)[[2]] # estimación del parámetro beta2
b2
seb2 <- sqrt(vcov(CAPM_SANTANDER)[2,2]) # est. desviación típica beta2
seb2
c <- 1
df <- df.residual(CAPM_SANTANDER) # grados de libertad
t_0 <- (b2-c)/seb2 # estadístico t
t_0
# Método del valor crítico
t_c <- qt(1-alpha/2, df) # valor crítico
t_c
# Gráfico de la función de densidad de la distribución t, del valor crítico 
# y del estadístico t_0
curve(dt(x, df), -6, 6, ylab=" ", xlab="t")
abline(v=c(-t_c, t_c, t_0), col=c("red", "red", "blue"), lty=c(2,2,3))
legend("topleft", legend=c("-t_c", "t_c", "t_0"), 
       col=c("red", "red", "blue"), lty=c(2, 2, 3))
# Método del P-valor
p <- 2*(1-pt(abs(t_0), df))
p
# Gráfico de la función de densidad de la distribución t y del estadístico t_0
curve(dt(x, df), -6, 6, ylab=" ", xlab="t")
abline(v=c(t_0), col=c("blue"), lty=c(3))
legend("topleft", legend=c("t_0"), col=c("blue"), lty=c(3))
# Estadístico F
H_0 <- "er_IBEX = 1"
linearHypothesis(CAPM_SANTANDER,H_0,test="F")
# Contraste conjunto de la hipótesis beta1=0, beta2=1
H_0 <- c("(Intercept) = 0", "er_IBEX = 1")
linearHypothesis(CAPM_SANTANDER,H_0,test="F")
# Contrastes unilaterales
#
# ¿Activo defensivo o agresivo?: beta2≤1 versus beta2>1
c <- 1
alpha <- 0.05
t_0 <- (b2-c)/seb2
t_0
# Método del valor crítico
t_c <- qt(1-alpha, df) # alpha no se divide por 2
t_c
curve(dt(x, df), -6, 6, ylab=" ", xlab="t")
abline(v=c(t_c, t_0), col=c("red", "blue"), lty=c(2, 3))
legend("topleft", legend=c("t_c", "t_0"), col=c("red", "blue"), lty=c(2, 3))
# Método del P-valor
p <- 1-pt(t_0, df)
p
# ¿Activo ultra-agresivo?: beta2≥2 versus beta2<2
c <- 2
alpha <- 0.05
t_0 <- (b2-c)/seb2
t_0
# Método del valor crítico
t_c <- qt(alpha, df) # alpha no se divide por 2
t_c
curve(dt(x, df), -20, 20, ylab=" ", xlab="t")
abline(v=c(t_c, t_0), col=c("red", "blue"), lty=c(2, 3))
legend("topleft", legend=c("t_c", "t_0"), col=c("red", "blue"), lty=c(2, 3))
# Método del P-valor
p <- pt(t_0, df)
p
# NOTA:
# Distribuciones de probabilidad en R ->
# https://rstudio.github.io/r-manuals/r-intro/Probability-distributions.html
```

## Código Python {.unnumbered}

```{python}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
import statsmodels.formula.api as smf
# Librería SciPy (stats): https://docs.scipy.org/doc/scipy/tutorial/stats.html
import scipy as sp 
# Lectura de datos
CAPM_ESP = pd.read_csv('data/CAPM_ESP.csv', delimiter=';', 
parse_dates=['date'], index_col='date')
CAPM_ESP.head()
CAPM_ESP.tail()
# Transformación de variables
def LogDiff(x):
    x_diff = 100*np.log(x/x.shift(1))
    return x_diff
CAPM_ESP['r_IBEX'] = LogDiff(CAPM_ESP['P_IBEX35'])
CAPM_ESP['r_SAN'] = LogDiff(CAPM_ESP['P_SANTANDER'])
CAPM_ESP['r_LT1Y'] = CAPM_ESP['R_LT1Y']/12
CAPM_ESP['er_IBEX'] = LogDiff(CAPM_ESP['P_IBEX35']) - CAPM_ESP['R_LT1Y']/12
CAPM_ESP['er_SAN'] = LogDiff(CAPM_ESP['P_SANTANDER']) - CAPM_ESP['R_LT1Y']/12
# Gráficas de las variables del modelo
plt.figure(1)
plt.plot(CAPM_ESP['er_IBEX'], label='Exceso de rendimiento IBEX35')
plt.plot(CAPM_ESP['er_SAN'], label='Exceso de rendimiento Banco Santander')
plt.xlabel('Date')
plt.ylabel('%')
plt.title('Variables del modelo CAPM para el Banco Santander')
plt.legend()
plt.show()
# Diagrama de puntos asociado a la regresión
plt.figure(2)
plt.scatter(CAPM_ESP['er_IBEX'], CAPM_ESP['er_SAN'])
plt.xlabel('er_IBEX')
plt.ylabel('er_SAN')
plt.title('Exceso de rendimiento de SAN frente a IBEX')
plt.show()
# Modelo CAPM para las acciones del Banco Santander
formula = 'er_SAN ~ er_IBEX'
CAPM_SANTANDER = smf.ols(formula, CAPM_ESP).fit()
print(CAPM_SANTANDER.summary())
# Intervalos de confianza para los parámetros estructurales del modelo
# Automático
CAPM_SANTANDER.conf_int()
# Manualmente
t_c = np.array(sp.stats.t.interval(0.95,CAPM_SANTANDER.df_resid))
CAPM_SANTANDER.params[0]+CAPM_SANTANDER.bse[0]*t_c
CAPM_SANTANDER.params[1]+CAPM_SANTANDER.bse[1]*t_c
# ANOVA
sm.stats.anova_lm(CAPM_SANTANDER)
# Ajuste del modelo (R^2)
CAPM_SANTANDER.rsquared
# Estadístico F de significación global
CAPM_SANTANDER.fvalue, CAPM_SANTANDER.f_pvalue
# Estadístico F y R^2
F_0 = (CAPM_SANTANDER.rsquared/(CAPM_SANTANDER.df_model))/((1-CAPM_SANTANDER.rsquared)/(CAPM_SANTANDER.df_resid))
F_0, 1-sp.stats.f.cdf(F_0, CAPM_SANTANDER.df_model, CAPM_SANTANDER.df_resid)
# Número de obsevaciones
CAPM_SANTANDER.nobs
# Número de parámetros
1+CAPM_SANTANDER.df_model
# Errores estimados (residuos) del modelo
plt.figure(3)
plt.plot(CAPM_SANTANDER.resid, label='res')
plt.xlabel('Date')
plt.title('Residuos del modelo CAPM para el Banco Santander')
plt.legend()
plt.show()
# Histograma de los residuos y comparación con la distribución normal
ebar = np.mean(CAPM_SANTANDER.resid)
sdehat = np.std(CAPM_SANTANDER.resid)
plt.figure(4)
fig, ax = plt.subplots()
ax.hist(CAPM_SANTANDER.resid, bins=20, density=True, 
edgecolor='white', linewidth=1.2)
x = np.linspace(min(CAPM_SANTANDER.resid), max(CAPM_SANTANDER.resid), 100)
ax.plot(x, sp.stats.norm.pdf(x, ebar, sdehat), color='black', 
label = 'Distribución normal')
plt.title('Residuos del modelo CAPM para el Banco Santander')
plt.xlabel('Residuos')
plt.ylabel('Densidad')
plt.legend(loc='best')
plt.tight_layout()
plt.show()
# Contrastes de hipótesis bilaterales
# beta1=0 versus beta1≠0
# Estadístico t
t_stat = (CAPM_SANTANDER.params['Intercept']-0)/CAPM_SANTANDER.bse['Intercept']
t_stat, 2*sp.stats.t.cdf(t_stat, CAPM_SANTANDER.df_resid)
# Estadístico F y P-valor
H_0 = 'Intercept = 0'
F_0 = CAPM_SANTANDER.f_test(H_0)
print(F_0)
# beta2=1 versus beta2≠1
# Estadístico t y P-valor
t_0 = (CAPM_SANTANDER.params['er_IBEX']-1)/CAPM_SANTANDER.bse['er_IBEX']
t_0, 2*(1-sp.stats.t.cdf(abs(t_0), CAPM_SANTANDER.df_resid))
# Estadístico F y P-valor
H_0 = 'er_IBEX = 1'
F_0 = CAPM_SANTANDER.f_test(H_0)
print(F_0)
# Contraste conjunto de la hipótesis beta1=0, beta2=1
# Estadístico F y P-valor
H_0 = 'Intercept = 0 , er_IBEX = 1'
F_0 = CAPM_SANTANDER.f_test(H_0)
print(F_0)
# Contrastes unilaterales
# beta2≤1 versus beta2>1
# Estadístico t y P-valor
t_0 = (CAPM_SANTANDER.params['er_IBEX']-1)/CAPM_SANTANDER.bse['er_IBEX']
t_0, 1-sp.stats.t.cdf(t_0, CAPM_SANTANDER.df_resid)
# beta2≥2 versus beta2<2
# Estadístico t y P-valor
t_0 = (CAPM_SANTANDER.params['er_IBEX']-2)/CAPM_SANTANDER.bse['er_IBEX']
t_0, sp.stats.t.cdf(t_0, CAPM_SANTANDER.df_resid)
# NOTA:
# Distribuciones de probabilidad en Python (librería SciPy) ->
# https://docs.scipy.org/doc/scipy/reference/stats.html
```
