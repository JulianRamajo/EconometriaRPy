---
title: 'TEMA 3: Estabilidad de los parámetros estructurales'
author:
  name: Julián Ramajo, ramajo@unex.es
  affiliation: GRADO EN ESTADÍSTICA | ECONOMETRIA (502243)
subtitle: 'Aplicaciones 3.2: Exportaciones españolas. Diferenciación salarial por sexo. Gasto en construcción'
output:
  html_document:
    theme: journal
    highlight: haddock
    toc: yes
    toc_depth: 2
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
---

# Objetivo

En esta aplicación se estimarán varias regresiones que permiten parámetros no constantes.

# Código R

## Diferencia salarial por sexo

```{r, message = FALSE, warning = FALSE}
# Lectura de librerías
library(tidyverse)
library(car)
# Lectura de datos
SAL_SEX <- read_csv("SAL_SEX.csv")
Boxplot(~SALARIO, data=SAL_SEX, main="", ylab="SALARIO", id=list(method = "none"))
class(SAL_SEX$MUJER)
SEXO <- factor(SAL_SEX$MUJER, labels=c("Hombre", "Mujer"))
summary(SEXO)
Boxplot(SALARIO~SEXO, data=SAL_SEX, ylab="SALARIO", id=list(method = "none"))
# Ecuación de salarios
summary(lm_SAL <- lm(log(SALARIO) ~ EDUC + EXPER , data = SAL_SEX))
# Gráficas parciales con diferenciación por sexo
scatterplot(log(SALARIO) ~ EDUC| SEXO, data=SAL_SEX, smooth=FALSE, boxplots=FALSE, ylab="Relación parcial log(Salario)/Educación")
scatterplot(log(SALARIO) ~ EXPER| SEXO, data=SAL_SEX, smooth=FALSE, boxplots=FALSE, ylab="Relación parcial log(Salario)/Experiencia")
# ¿Existe realmente diferenciación por sexos? (estadísticamente significativa)
summary(lm_SAL_h <- lm(log(SALARIO) ~ EDUC + EXPER , data = SAL_SEX[which(SAL_SEX$MUJER==0),]))
summary(lm_SAL_m <- lm(log(SALARIO) ~ EDUC + EXPER , data = SAL_SEX[which(SAL_SEX$MUJER==1),]))
compareCoefs(lm_SAL_h, lm_SAL_m)
# Test de Chow
summary(lm_SAL_int <- lm(log(SALARIO) ~ EDUC + EXPER + MUJER/(EDUC + EXPER), data = SAL_SEX))
anova(lm_SAL, lm_SAL_int)
# Regresión diferenciada por sexos
summary(lm_SAL_int <- lm(log(SALARIO) ~ (EDUC + EXPER)*MUJER, data = SAL_SEX))
```

## Exportaciones españolas

```{r, message = FALSE, warning = FALSE}
# Lectura de librerías
library(tidyverse)
library(car)
# Lectura de datos
EXP_ESP <- read_delim("EXP_ESP_Y.csv", delim = ";")
# División de la muestra preUE (1970-1985) y postUE (1986-1997)
Y1986 = match(as.Date("1986-01-01"), EXP_ESP$date)
Y1986
UE <- factor(c(rep(0, 16), rep(1, 12)), labels=c("preUE", "postUE"))
UE
class(UE)
EXP_ESP$D1986 <- as.numeric(UE)-1
EXP_ESP$D1986
class(EXP_ESP$D1986)
EXP_ESP_ts <- ts(EXP_ESP[,2:5], start=c(1970), end = c(1997), frequency = 1)
plot(EXP_ESP_ts)
# Ecuación de exportaciones (1970-1997)
lm_X_ESP <- lm(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts)
summary(lm_X_ESP)
# Gráficas parciales con diferenciación por período
scatterplot(log(XGS) ~ log(WGDP)| D1986, data=EXP_ESP_ts, smooth=FALSE, boxplots=FALSE, 
            ylab="Relación parcial Exportaciones/PIB mundial (logs)")
scatterplot(log(XGS) ~ log(REER)| D1986, data=EXP_ESP_ts, smooth=FALSE, boxplots=FALSE, 
            ylab="Relación parcial Exportaciones/Tipo de cambio (logs)")
# ¿Existe diferenciación por períodos? (estadísticamente significativa)
# Test de Chow de cambio estructural
#  Cálculo manual
summary(lm_X_ESP)
SRCT <- sum(residuals(lm_X_ESP)^2)
SRCT
T <- nobs(lm_X_ESP)
T
K <- T -df.residual(lm_X_ESP)
K
# PreUE
preUE <- window(EXP_ESP_ts, start=1970, end = 1985)
lm_X_ESP_preUE <- lm(log(XGS) ~ log(WGDP) + log(REER) , data = preUE)
summary(lm_X_ESP_preUE)
SRC1 <- sum(residuals(lm_X_ESP_preUE)^2)
SRC1
T1 <- nobs(lm_X_ESP_preUE)
T1
# PostUE
postUE <- window(EXP_ESP_ts, start=1986, end = 1997)
lm_X_ESP_postUE <- lm(log(XGS) ~ log(WGDP) + log(REER) , data = postUE)
summary(lm_X_ESP_postUE)
SRC2 <- sum(residuals(lm_X_ESP_postUE)^2)
SRC2
T2 <- nobs(lm_X_ESP_postUE)
T2
# Estadístico de contraste
CHOW=((SRCT-(SRC1+SRC2))/K)/((SRC1+SRC2)/(T-2*K))
CHOW
pval <-  1-pf(CHOW,K,(T-2*K))
pval
# Comparación de parámetros
compareCoefs(lm_X_ESP_preUE,lm_X_ESP_postUE)
# Cálculo directo
# Método 1 (ANOVA)
summary(lm_X_EXP_int <- lm(log(XGS) ~ log(WGDP) + log(REER) + D1986/(log(WGDP) + log(REER)), data = EXP_ESP_ts))
anova(lm_X_ESP, lm_X_EXP_int)
# Método 2 (librería structchange)
library(strucchange)
sctest(log(XGS) ~ log(WGDP) + log(REER), data=EXP_ESP_ts, type = "Chow", point = Y1986-1)
# Contrastes tipo Chow basados en estimaciones recursivas
sbtest <- Fstats(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts, from = 0.15, to = 0.85)
sbtest[["Fstats"]]
# Gráfica de los estadísticos F 
plot(sbtest, alpha = 0.05)
# Test de Chow (1960) [versión Chi2]
Chow_F <- sbtest$Fstats[Y1986-4] # Punto de ruptura: 17 - 4 (15% suprimidos a la izquierda)
Chow_F # Se puede comprobar que Chow_F/K=CHOW
# Chow_F tiene una distribución asintótica Chi^2 mientras que
# Chow_F/K tiene una distribución exacta F_K,T-2*K
pval <-  1-pchisq(Chow_F,sbtest$nreg) 
pval
# Contrastes de Andrews (1993) y Andrews y Ploberger (1994) [punto de ruptura desconocido]
sctest(sbtest, type = "supF")
sctest(sbtest, type = "aveF")
sctest(sbtest, type = "expF")
# Test CUSUM (Brown, Durbin y Evans, 1975)
plot(efp(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts))
# Regresión diferenciada por tramos
summary(lm(log(XGS) ~ (log(WGDP) + log(REER))*D1986, data=EXP_ESP_ts))
# Versión alternativa
summary(lm(log(XGS) ~ (log(WGDP) + log(REER))*UE, data=EXP_ESP_ts))
#
compareCoefs(lm_X_ESP_preUE,lm_X_ESP_postUE)
```

## Inversión en construcción en Estados Unidos

```{r, message = FALSE, warning = FALSE}
# Lectura de librerías
library(tidyverse)
library(plotly)
# Lectura de datos: y = Total Construction Spending (TTLCON) 
# [https://fred.stlouisfed.org/series/TTLCON)]
TCS <- read_csv("TTLCON_USA.csv") %>% setNames(c("date","y"))
head(TCS)
tail(TCS)
class(TCS)
str(TCS)
# Gráfica de los datos
plot_ly(data = TCS) %>% add_lines(x = ~ date, y = ~ y)
# Construcción de tendencias
TCS <- TCS %>%
  mutate(seg1 = 1:nrow(TCS),
         seg2 = pmax(0, seg1 - min(seg1[seg1[which(date > as.Date("2007-08-01"))]])),
         seg3 = pmax(0, seg1 - min(seg1[seg1[which(date > as.Date("2011-01-01"))]])))
# Modelo con tendencia simple
mod1 <- lm(y ~ seg1, data = TCS)
summary(mod1)
# Modelo con tendencias sementadas (con pivote conocido)
mod2 <- lm(y ~ seg1 + seg2 + seg3, data = TCS)
summary(mod2)
TCS$yhat1 <- predict(mod1)
TCS$yhat2 <- predict(mod2)
# Gráfica de los datos con las tendencias ajustadas por los dos modelos
plot_ly(data = TCS) %>%
  add_markers(x = ~ date,
              y = ~ y,
              marker = list(
                opacity = 0.6,
                color = "grey",
                size = 8),
              name = "Gasto en construcción") %>%
  add_lines(x = ~ date,
          y = ~ yhat1,
          line = list(color = "red",
                      dash = "dash",
                      width = 4),
          name = "Tendencia simple") %>%
  add_lines(x = ~ date,
            y = ~ yhat2,
            line = list(color = "#fca311",
                        dash = "dot",
                        width = 6),
            name = "Tendencia segmentada") %>%
  layout(title = "Gasto total en construcción en USA",
         font = list(color = "black"),
         yaxis = list(title = "Millones de dólares"),
         xaxis = list(title = "Fuente: U.S. Census Bureau, Total Construction Spending, extraído de FRED (fred.stlouisfed.org)"),
         margin = list(t = 50, b = 80),
         legend = list(x = 0.05, y = 0.95))
```

# Código Python

## Diferencia salarial por sexo

```{python, message = FALSE, warning = FALSE}
# Lectura de librerías
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import scipy as sp
import statsmodels.api as sm
import statsmodels.formula.api as smf
import statsmodels.stats as smstats
# Lectura de datos
SAL_SEX = pd.read_csv("SAL_SEX.csv")
plt.figure(1)
sns.boxplot(x=SAL_SEX["SALARIO"])
plt.show()
SAL_SEX['SEXO']=SAL_SEX['MUJER'].astype('category')
SAL_SEX['SEXO']=SAL_SEX['SEXO'].cat.rename_categories(['Hombre', 'Mujer'])
plt.figure(2)
sns.boxplot(x=SAL_SEX["SALARIO"] , y=SAL_SEX["SEXO"])
plt.show()
# Ecuación de salarios
lm_SAL = smf.ols(formula='np.log(SALARIO) ~ EDUC + EXPER', data=SAL_SEX).fit()
print(lm_SAL.summary())
# Gráficas parciales con diferenciación por sexo
SAL_SEX['l_SALARIO']=np.log(SAL_SEX['SALARIO'])
plt.figure(3)
sns.lmplot(x="EDUC", y="l_SALARIO", hue="SEXO", data=SAL_SEX);
plt.show()
plt.figure(5)
sns.lmplot(x="EXPER", y="l_SALARIO", hue="SEXO", data=SAL_SEX);
plt.show()
# Diferenciación por sexos
# Hombres
lm_SAL_h = smf.ols(formula='np.log(SALARIO) ~ EDUC + EXPER', subset=(SAL_SEX['MUJER'] == 0), data=SAL_SEX).fit()
print(lm_SAL_h.summary())
# Mujeres
lm_SAL_m = smf.ols(formula='np.log(SALARIO) ~ EDUC + EXPER', subset=(SAL_SEX['MUJER'] == 1), data=SAL_SEX).fit()
print(lm_SAL_m.summary())
# Regresión diferenciada por sexos
lm_SAL_int = smf.ols(formula='np.log(SALARIO) ~ (EDUC + EXPER)*MUJER', data=SAL_SEX).fit()
print(lm_SAL_int.summary())
sm.stats.anova_lm(lm_SAL,lm_SAL_int) # test de Chow
```

## Exportaciones españolas

```{python, message = FALSE, warning = FALSE}
# Lectura de librerías
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import scipy as sp
import statsmodels.api as sm
import statsmodels.formula.api as smf
import statsmodels.stats as smstats
# Lectura de datos
EXP_ESP = pd.read_csv("EXP_ESP_Y.csv", sep=";", parse_dates=['date'], index_col='date')
date = pd.date_range(start = '1970', periods = len(EXP_ESP.index), freq = 'Y')
EXP_ESP.index = date
EXP_ESP.info()
EXP_ESP.head()
EXP_ESP.index
EXP_ESP['D1986'] = np.where(EXP_ESP.index > '1985-12-31', 1, 0)
EXP_ESP['UE']=EXP_ESP['D1986'].astype('category')
EXP_ESP['UE']=EXP_ESP['UE'].cat.rename_categories(['preUE', 'postUE'])
# Ecuación de exportaciones (1970-1997)
lm_X_ESP = smf.ols(formula='np.log(XGS) ~ np.log(WGDP) + np.log(REER)', data=EXP_ESP).fit()
print(lm_X_ESP.summary())
# Gráficas parciales con diferenciación por período
EXP_ESP['l_XGS']=np.log(EXP_ESP['XGS'])
EXP_ESP['l_WGDP']=np.log(EXP_ESP['WGDP'])
EXP_ESP['l_REER']=np.log(EXP_ESP['REER'])
plt.figure(7)
sns.lmplot(x="l_WGDP", y="l_XGS", hue="UE", data=EXP_ESP);
plt.show()
plt.figure(9)
sns.lmplot(x="l_REER", y="l_XGS", hue="UE", data=EXP_ESP);
plt.show()
# Diferenciación por períodos
# PreUE
lm_X_ESP_preUE = smf.ols(formula='np.log(XGS) ~ np.log(WGDP) + np.log(REER)', subset=(EXP_ESP['D1986'] == 0), data=EXP_ESP).fit()
print(lm_X_ESP_preUE.summary())
# PostUE
lm_X_ESP_postUE = smf.ols(formula='np.log(XGS) ~ np.log(WGDP) + np.log(REER)', subset=(EXP_ESP['D1986'] == 1), data=EXP_ESP).fit()
print(lm_X_ESP_postUE.summary())
# Regresión diferenciada por tramos
lm_X_ESP_int = smf.ols(formula='np.log(XGS) ~ (np.log(WGDP) + np.log(REER))*D1986', data=EXP_ESP).fit()
print(lm_X_ESP_int.summary())
sm.stats.anova_lm(lm_X_ESP,lm_X_ESP_int) # test de Chow
```
