---
engine: knitr
excerpt: ""
draft: false
format: 
  html:
    theme: simplex
    self-contained: true
    max-width: 1920px
    code-fold: show
    code-tools: true
    highlight-style: atom-one-dark
    code-block-bg: "#282c34"
---

```{css, echo = FALSE}
.justify { text-align: justify !important }
```

::: justify
# Aplicación 3.9: Información muestral (falta de observaciones) {.unnumbered}

## Exclusión social en el comportamiento de las aseguradoras de Chicago {.unnumbered}

En esta aplicación se usarán los datos de un estudio de la década de 1970 sobre la relación entre la exclusión social de los seguros y la composición racial, los índices de incendio y robo, la antigüedad de las viviendas y los ingresos en 47 distritos postales de Chicago.
:::

## Código R {.unnumbered}

```{r}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
library(tidyverse)
# Lectura de datos
# library(faraway)
# help(chredlin, package="faraway")
chmiss <- read.csv("data/SEGUROS_CHICAGO.csv", header=TRUE, row.names="zip") 
# Versión tidyverse: read_csv("SEGUROS_CHICAGO.csv") %>% 
# column_to_rownames(., var = "zip")
chmiss
summary(chmiss)
# Detección de datos perdidos
# Por filas (casos)
rowSums(is.na(chmiss))
image(is.na(chmiss),axes=FALSE)
axis(2, at=0:5/5, labels=colnames(chmiss),las=2)
axis(1, at=0:46/46, labels=row.names(chmiss),las=2)
# Por columnas (variables)
colSums(is.na(chmiss))
library(mi)
md <- missing_data.frame(chmiss)
image(md)
summary(md@patterns)
# Tratamiento de datos perdidos
# Omisión de observaciones (opción por defecto en R) 
# Resultados con datos completos
mod_1 <- lm(involact ~ race+fire+theft+age+log(income), chmiss)
summary(mod_1)
# Imputación simple
# Uso de la media para predecir los datos que faltan de los regresores
(cmeans <- colMeans(chmiss,na.rm=TRUE))
imput_1 <- chmiss
for(i in c(1:4,6)) imput_1[is.na(chmiss[,i]),i] <- cmeans[i] # Sólo var. expl.
mod_2 <- lm(involact ~ race+fire+theft+age+log(income), imput_1)
summary(mod_2)
# Uso de regresiones para predecir los datos que faltan 
# de las variables explicativas
mod_race <- lm(race ~ fire+theft+age+income,chmiss)
chmiss[is.na(chmiss$race),]
predict(mod_race,chmiss[is.na(chmiss$race),])
# Como la predicción para la zona 60646 es negativa, 
# se puede usar la transformación logit ( log(y/(1-y)) ) 
# para evitar que las predicciones se salgan del intervalo [0,1] 
# y luego aplicar la transformación inversa a la predicción
library(faraway)
mod_race_2 <- lm(logit(race/100) ~ fire+theft+age+income,chmiss)
ilogit(predict(mod_race_2,chmiss[is.na(chmiss$race),]))*100
mod_fire <- lm(fire ~ race+theft+age+income,chmiss)
chmiss[is.na(chmiss$fire),]
predict(mod_fire,chmiss[is.na(chmiss$fire),])
mod_theft <- lm(theft ~ race+fire+age+income,chmiss)
chmiss[is.na(chmiss$theft),]
predict(mod_theft,chmiss[is.na(chmiss$theft),])
mod_age <- lm(age ~ race+fire+theft+income,chmiss)
chmiss[is.na(chmiss$age),]
predict(mod_age,chmiss[is.na(chmiss$age),])
mod_income <- lm(income ~ race+fire+theft+age,chmiss)
chmiss[is.na(chmiss$income),]
predict(mod_income,chmiss[is.na(chmiss$income),])
# Generación de valores para los datos perdidos por variable
imput_2  <- chmiss
imput_2$race[is.na(chmiss$race)] <- 
  ilogit(predict(mod_race_2,chmiss[is.na(chmiss$race),]))*100
imput_2$fire[is.na(chmiss$fire)] <- 
  predict(mod_fire,chmiss[is.na(chmiss$fire),])
imput_2$theft[is.na(chmiss$theft)] <-  
  predict(mod_theft,chmiss[is.na(chmiss$theft),])
imput_2$age[is.na(chmiss$age)] <-  
  predict(mod_age,chmiss[is.na(chmiss$age),])
imput_2$income[is.na(chmiss$income)] <-  
  predict(mod_income,chmiss[is.na(chmiss$income),])
#
mod_3 <- lm(involact ~ race+fire+theft+age+log(income), imput_2)
summary(mod_3)
# Imputación múltiple 
# Enfoque AMELIA (https://cran.r-project.org/web/packages/Amelia/index.html)
library(Amelia)
imput_3 <- amelia(chmiss, m=10)
summary(imput_3)
betas <- NULL
se_betas <- NULL
for(i in 1:imput_3$m){
  lmod <- lm(involact ~ race+fire+theft+age+log(income), imput_3$imputations[[i]])
  betas <- rbind(betas ,coef(lmod))
  se_betas <- rbind(se_betas ,coef(summary(lmod))[,2])
}
# Estimaciones, desviaciones estándar estimadas y estadísticos t 
# (individuales y combinadas)
betas; se_betas
(cr <- mi.meld(q=betas,se=se_betas))
(cr$q.mi/cr$se.mi)
# Enfoque MICE (https://cran.r-project.org/web/packages/mice/)
library(mice)
# Patrón de datos perdidos
md.pattern(chmiss)
# Imputación simple con la media de los datos completos
imp_4_0 <- mice(chmiss, method = "mean", m = 1, maxit = 1)
imput_1_2 <- complete(imp_4_0) # Se obtiene el mismo resultado que 
# en el fichero imput_1, pera también se imputan
summary(with(imput_1_2, lm(involact ~ race+fire+theft+age+log(income))))
# Imputación por el método de regresión (1):
# Predicción simple
imp_4_1 <- mice(chmiss, method = "norm.predict", m = 1, maxit = 1) 
imput_2_1 <- complete(imp_4_1) # Comparar con el fichero imput_2
# Imputación por el método de regresión (2):
# Predicción estocástica (se añade un error aleatorio)
imp_4_2 <- mice(chmiss, method = "norm.nob", m = 1, maxit = 1) 
imput_2_2 <- complete(imp_4_2) # Comparar con el fichero imput_2
# Imputación por el método de regresión (3):
# Predicción usando booostrap
imp_4_3 <- mice(chmiss, method = "norm.boot", m = 1, maxit = 1) 
imput_2_3 <- complete(imp_4_3) # Comparar con el fichero imput_2
# MICE: Multiple Imputation Chained Equation
imp_4 <- mice(chmiss, m = 10, print=F)
summary(imp_4)
class(imp_4) # mids: multiply imputed data set
attributes(imp_4)
# Para ver los datos imputados de una variable
imp_4$imp # Todas las imputaciones
# Imputaciones para una variable: 
# cambiar race por otra variable para ver el resultado
imp_4$imp$race 
# Para guardar los datos completos de una imputación
imp_4_m_1 <- complete(imp_4,1) # cambiar 1 por cualquier valor entre 1 y 10
#
# Inspección de la calidad de las imputaciones
# Convergencia del algoritmo (iterative Markov Chain Monte Carlo)
plot(imp_4)
# Gráfica conjunta
stripplot(imp_4)
# Gráfica individual
stripplot(imp_4, involact, pch = 20, xlab = "Imputation number")
stripplot(imp_4, race, pch = 20, xlab = "Imputation number")
stripplot(imp_4, fire, pch = 20, xlab = "Imputation number")
stripplot(imp_4, theft, pch = 20, xlab = "Imputation number")
stripplot(imp_4, age, pch = 20, xlab = "Imputation number")
stripplot(imp_4, income, pch = 20, xlab = "Imputation number")
# Distribución de los datos completos y los completados
xyplot(imp_4,involact ~ race+fire+theft+age+income)
densityplot(imp_4)
# Ajuste de los modelos con los datos completados (m modelos)
fit <- with(imp_4, lm(involact ~ race+fire+theft+age+log(income)))
# Pool y resumen de resultados
fit # Resultado de la regresión para cada conjunto de datos imputados (m=10 en el ejemplo)
# Para ver el resultado de una regresión concreta (la primera por ejemplo)
summary(fit$analyses[[1]])
# Pool de resultados de regresión
summary(pool(fit))
# Comparación de los resultados a posteriori, con la muestra completa
data(chredlin, package="faraway")
mod_full <- lm(involact ~ race+fire+theft+age+log(income), chredlin)
summary(mod_full)
```

## Código Python {.unnumbered}

```{python}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import statsmodels.formula.api as smf
# Lectura de datos
chmiss = pd.read_csv("data/SEGUROS_CHICAGO.csv", index_col=0)
chmiss.describe().round(2)
# Detección de datos perdidos
# Por filas (casos)
chmiss.isna().sum(axis=1)
plt.imshow(~chmiss.isna(), aspect='auto')
plt.xlabel("variables")
plt.ylabel("cases")
plt.gray()
plt.show()
# Por columnas (variables)
chmiss.isna().sum(axis=0)
# Tratamiento de datos perdidos
# Omisión de los datos perdidos: resultados con datos completos
mod_1 = smf.ols(formula='involact ~ race + fire + theft + age + np.log(income)', 
data=chmiss).fit()
print(mod_1.summary())
# Imputación simple: uso de la media para predecir los datos que faltan de los regresores
cmeans = chmiss.mean(axis=0)
cmeans
imput_1 = chmiss.copy()
imput_1.race.fillna(cmeans['race'],inplace=True)
imput_1.fire.fillna(cmeans['fire'],inplace=True)
imput_1.theft.fillna(cmeans['theft'],inplace=True)
imput_1.age.fillna(cmeans['age'],inplace=True)
imput_1.income.fillna(cmeans['income'],inplace=True)
mod_2 = smf.ols(formula='involact ~ race + fire + theft + age + np.log(income)', data=imput_1).fit()
print(mod_2.summary())
# Imputación múltiple: enfoque MICE 
# (https://www.statsmodels.org/stable/imputation.html)
# NOTA: la librería statsmodels incluye el método MICE, pero no es 
# exactamente el mismo que el usado en R
import statsmodels.imputation.mice as smimice
imp = smimice.MICEData(chmiss)
formula = 'involact ~ race + fire + theft + age + np.log(income)'
mod_3 = smimice.MICE(formula, sm.OLS, imp)
results = mod_3.fit(10, 10)
print(results.summary())
```
