---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

# R code

```{r}
library(readxl)
macro <- read_excel("~/Dropbox/Mi Mac (Mac Pro de Julián)/Documents/GitHub/EcoMetricsRPy/APT.xls")
head(macro)
#
macro$dspread = c(NA,diff(macro$BMINUSA))
macro$dcredit = c(NA,diff(macro$CCREDIT))
macro$dprod = c(NA,diff(macro$INDPRO))
macro$dmoney = c(NA,diff(macro$M1SUPPLY))
macro$inflation = c(NA,100*diff(log(macro$CPI)))
macro$rterm = c(NA,diff(macro$USTB10Y-macro$USTB3M))
macro$dinflation = c(NA,100*diff(macro$inflation))
macro$r_sp = c(NA,100*diff(log(macro$SANDP)))
macro$er_sp = c(NA,100*diff(log(macro$SANDP)))-macro$USTB3M/12
macro$er_msoft = c(NA,100*diff(log(macro$MICROSOFT)))-macro$USTB3M/12
#
APT_msoft = lm(er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm, data = macro)
summary(APT_msoft)
#
library(car)
linearHypothesis(APT_msoft,c("dprod=0","dcredit=0","dmoney=0","dspread=0"))
#
# Diagnosis del modelo
#
# Heteroscedasticidad
#
# Gráfico de errores estimados (residuos)
plot(macro$Date[-(1:2)],APT_msoft$residuals,type = "l",xlab="",ylab="")
# Test de Breusch-Pagan de heteroscedasticidad aditiva
library(lmtest)
bptest(formula(APT_msoft),data = macro,studentize = F)
bptest(formula(APT_msoft),data = macro,studentize = T)
# Corrección de la matriz de covarianzas
library(sandwich)
coeftest(APT_msoft,vcov. = vcovHC(APT_msoft,type="HC1")) # White
coeftest(APT_msoft,vcov. = NeweyWest(APT_msoft,lag = 6,adjust = T,prewhite = F)) # Newey-West
#
# Autocorrelación
#
# Test de Durbin-Watson
dwtest(APT_msoft)
# Test de Breuscgh-Godfrey
bgtest(APT_msoft,order = 10)
#
# Heteroscedasticidad autorregresiva condicional (ARCH)
#
library(FinTS)
ArchTest(APT_msoft$residuals , lags = 1)
# Normalidad  de los errores
#
# Histograma de los residuos
hist(APT_msoft$residuals,main = "")
box()
# Estadísticos de normalidad
library(moments)
skewness(APT_msoft$residuals)
kurtosis(APT_msoft$residuals)
jarque.test(APT_msoft$residuals)
agostino.test(APT_msoft$residuals)
anscombe.test(APT_msoft$residuals)
# Sucesos especiales (uso de variables ficticias para modelizar la presencia de 'algunos' outliers)
plot(macro$Date[-(1:2)],APT_msoft$residuals,type = "l", col="red",xlab="",ylab="")
lines(macro$Date[-(1:2)],APT_msoft$fitted.values)
legend("bottomright",c("Residuals","Fitted"), col = c("red","black"),lty=1)
#
macro$Date = as.Date(macro$Date)
macro$APR2000DUM = as.integer(macro$Date == as.Date("2000-04-01"))
macro$DEC2000DUM = as.integer(macro$Date == as.Date("2000-12-01"))
APT_msft_dummy = lm(er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney+ dspread + rterm + 
                      APR2000DUM + DEC2000DUM, data = macro)
summary(APT_msft_dummy)
# Períodos especiales
require(lubridate)
macro$JANDUM = as.integer(month(macro$Date) == 1)
summary(lm(er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm + 
             APR2000DUM + DEC2000DUM + JANDUM, data = macro))
#
# Multicolinealidad
#
library(car)
library(corrplot)
# Matriz de correlaciones
cor(macro[-(1:2),c("dprod","dcredit","dinflation","dmoney","dspread","rterm")])
corrplot(cor(macro[-(1:2),c("dprod","dcredit","dinflation","dmoney","dspread","rterm")]))
# FIVs
vif(APT_msoft)
#
# Forma funcional
#
# Test de Ramsey
resettest(APT_msoft,power = 2:3)
#
# Estabilidad de los parámetros
#
library(strucchange)
sbtest = Fstats(formula(APT_msoft),data = macro) # Recorte del 15% en ambos lados de la muestra (15% de 383 obs. -> 57)
# Test de Chow con punto de ruptura conocido
JAN1996 = match(as.Date("1996-01-01"),macro$Date)
chow = sbtest$Fstats[JAN1996-2-57] # Punto ruptura (breakpoint): 2 NAs + 57 -> 59
chow
1-pchisq(chow,sbtest$nreg)
# Test de Chow recursivo (punto de ruptura desconocido)
sctest(sbtest)
bp = which.max(sbtest$Fstats)+59
macro$Date[bp]
# Estimación recursiva y test CUSUM
# Parámetros recursivos
beta = NULL # variable para introducir en cada paso el beta y su error estándar estimados
for (t in 20:nrow(macro)){
  lr = summary(lm(formula(APT_msoft), data = macro[3:t,]))
  beta = rbind(beta,lr$coefficients["er_sp",1:2])
  }
x_axis = macro$Date[20:nrow(macro)]
plot(x_axis,beta[,1],type = "l",ylim = c(0,3),xlab="",ylab="Beta")
lines(x_axis,beta[,1]+2*beta[,2],lty="dashed")
lines(x_axis,beta[,1]-2*beta[,2],lty="dashed")
# Test CUSUM
plot(efp(APT_msoft,data=macro))
#

```

# Python code

```{python}
import pandas as pd
import numpy as np
import statsmodels.api as sm
import statsmodels.formula.api as smf
import statsmodels.stats.api as sms
from statsmodels.stats.diagnostic import het_arch
from statsmodels.stats.outliers_influence import reset_ramsey
from statsmodels.compat import lzip
import scipy.stats as scs
import matplotlib.pyplot as plt
#
data = pd.read_excel('~/Dropbox/Mi Mac (Mac Pro de Julián)/Documents/GitHub/EcoMetricsRPy/APT.xls', index_col=0)
data.head()
#
def LogDiff(x):
    x_diff = 100*np.log(x/x.shift(1))
    return x_diff
data = pd.DataFrame({'dspread' : data['BMINUSA'] - data['BMINUSA'].shift(1),
                    'dcredit' : data['CCREDIT'] - data['CCREDIT'].shift(1),
                    'dprod' : data['INDPRO'] - data['INDPRO'].shift(1),
                    'r_msoft' : LogDiff(data['MICROSOFT']),
                    'r_sp' : LogDiff(data['SANDP']),
                    'dmoney' : data['M1SUPPLY'] - data['M1SUPPLY'].shift(1),
                    'inflation' : LogDiff(data['CPI']),
                    'term' : data['USTB10Y'] - data['USTB3M'],
                    'dinflation' : LogDiff(data['CPI']) - LogDiff(data['CPI']).shift(1),
                    'mustb3m' : data['USTB3M']/12,
                    'rterm' : (data['USTB10Y'] - data['USTB3M']) - (data['USTB10Y'] - data['USTB3M']).shift(1),
                    'er_msoft' : LogDiff(data['MICROSOFT']) - data['USTB3M']/12,
                    'er_sp' : LogDiff(data['SANDP']) - data['USTB3M']/12})
data.head()
# data = data.dropna()
#
formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
results = smf.ols(formula, data).fit()
print(results.summary())
# 
hypotheses = 'dprod = dcredit = dmoney = dspread = 0'
F_test = results.f_test(hypotheses)
print(F_test)
#
# Diagnosis del modelo
#
# Heteroscedasticidad
#
formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
results = smf.ols(formula, data).fit()
# Gráfico de errores estimados (residuos)
plt.figure(1)
plt.plot(results.resid)
plt.xlabel('Date')
plt.ylabel('Residuos')
plt.grid(True)
plt.show()
# Test de Breusch-Pagan (heter. aditiva)
name = ['Lagrange multiplier statistic', 'p-value', 
        'f-value', 'f p-value']
BP_test = sms.het_breuschpagan(results.resid, results.model.exog)
lzip(name, BP_test)
# Corrección de la matriz de covarianzas
# White
results1 = smf.ols(formula, data).fit(cov_type='HC1')
print(results1.summary())
# Newey-West (si maxlags=0 -> HAC=HC1)
results2 = smf.ols(formula, data).fit(cov_type='HAC', cov_kwds={'maxlags':6,'use_correction':True})
print(results2.summary())
#
# Autocorrelación
#
formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
results = smf.ols(formula, data).fit()
# Test de Durbin-Watson
residuals = results.resid
sms.durbin_watson(residuals)
# Test de Breuscgh-Godfrey
name = ['Lagrange multiplier statistic', 'p-value', 
        'f-value', 'f p-value']
BG_test = sms.acorr_breusch_godfrey(results, 10)
lzip(name, BG_test)
#
# Heteroscedasticidad autorregresiva condicional (ARCH)
#
formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
results = smf.ols(formula, data).fit()
# Test de Engle
name = ['lm','lmpval','fval','fpval'] 
E_test = het_arch(results.resid, nlags=1)
lzip(name,E_test)
#
# Normalidad de los errores
#
formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
results = smf.ols(formula, data).fit()
residuals = results.resid
# Histograma de los residuos
plt.figure(2)
plt.hist(residuals,20,edgecolor='black',linewidth=1.2)
plt.xlabel('Residuos')
plt.ylabel('Densidad estimada')
plt.show()
# Test de Jarque-Bera
name = ['Jarque-Bera', 'Chi^2 two-tail prob.', 'Skewness', 'Kurtosis']
JB_test = sms.jarque_bera(residuals)
lzip(name, JB_test)
#
# Contrastes de normalidad para una variable (var: ndarray)
def normality_tests(var):
  Skewness_test = scs.skew(var)
  Skewness_pvalue = scs.skewtest(var)[1]
  Kurtosis_test = scs.kurtosis(var)
  Kurtosis_pvalue = scs.kurtosistest(var)[1]
  Normality_test_pvalue = scs.normaltest(var)[1]
return Skewness_test, Skewness_pvalue, Kurtosis_test, Kurtosis_pvalue, Normality_test_pvalue
normality_tests(residuals)
#
# Modelización de sucesos especiales (uso de variables ficticias para tratar la presencia de outliers aislados)
formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
results = smf.ols(formula, data).fit()
y_fitted = results.fittedvalues
residuals = results.resid
#
plt.figure(3)
plt.plot(residuals, label='Residuos')
plt.plot(y_fitted, label='Valores ajustados')
plt.xlabel('Date')
plt.ylabel('Desviaciones')
plt.grid(True)
plt.legend()
plt.show()
# Identificación de valores menores
residuals.nsmallest(2)
#
data['APR2000DUM'] = np.where(data.index == '2000-4-1', 1, 0)
data['DEC2000DUM'] = np.where(data.index == '2000-12-1', 1, 0)
#
formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm + APR2000DUM + DEC2000DUM'
results = smf.ols(formula, data).fit()
print(results.summary())
#
# Multicolinealidad
#
# Matriz de correlaciones
# data = data.dropna()
dataX = data[['dprod','dcredit','dinflation','dmoney','dspread','rterm']]
dataX.corr()
#
# Forma funcional
#
# Test de Ramsey
formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
results = smf.ols(formula, data).fit()
reset_ramsey(results,degree=3)
#
# Estabilidad de los parámetros
#
# Test de Chow (punto de ruptura conocido)
def get_rss(data):
    '''
    inputs:
        data: a pandas DataFrame of independent and dependent variable
    outputs:
        rss: the residuals sum of squares
        N: the observations of inputs
        K: total number of parameters
    '''    
    formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
    results = smf.ols(formula, data).fit()
    rss = (results.resid**2).sum() # suma de residuos al cuadrado
    N = results.nobs
    K = results.df_model
    #
    return rss, N, K
# División por submuestras (split samples)
data1 = data[:'1996-01-01']
data2 = data['1996-01-01':]
# Muestra completa
RSS_total, N_total, K_total = get_rss(data)
# Primra submuestra
RSS_1, N_1, K_1 = get_rss(data1)
# Segunda submuestra
RSS_2, N_2, K_2 = get_rss(data2)
# Estadístico de contraste
numerador = (RSS_total - (RSS_1 + RSS_2)) / K_total
denominador = (RSS_1 + RSS_2) / (N_1 + N_2 - 2*K_total)
result = numerador/denominador
result
#
# Test de Chow recursivo (punto de ruptura desconocido)
formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
results = smf.ols(formula, data).fit()
name = ['test statistic', 'pval', 'crit']
test = sms.breaks_cusumolsresid(resid = results.resid, ddof = results.df_model)
lzip(name, test)
# Estimación recursiva y test CUSUM
data = data.dropna()
def recursive_reg(variable, i, interval):
    '''
    inputs:
        variable: the string literals of a variable name in regression formula
        i: the serial number of regression
        interval: the number of consective data points in initial sample
    outputs:
        coeff: the coefficient estimation of the variable
        se: the standard errors of the variable
    '''
    formula = 'er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm'
    results = smf.ols(formula, data.iloc[:i+interval]).fit()
    coeff = results.params[variable]
    se = results.bse[variable]
    #
    return coeff, se
#
parameters = []
for i in range(373):
    coeff, se = recursive_reg('er_sp', i, 11)
    parameters.append((coeff,se))
    
parameters = pd.DataFrame(parameters, columns=['coeff','se'], index = data[:-10].index)

parameters['er_sp + 2*se'] = parameters['coeff'] + 2*parameters['se']
parameters['er_sp - 2*se'] = parameters['coeff'] - 2*parameters['se']
#
plt.figure(4)
plt.plot(parameters['coeff'], label=r'$\beta_{er_sp}$')
plt.plot(parameters['er_sp + 2*se'], label=r'$\beta_{er_sp} + 2*se$', linestyle='dashed')
plt.plot(parameters['er_sp - 2*se'], label=r'$\beta_{er_sp} - 2*se$', linestyle='dashed')
plt.xlabel('Date')
plt.grid(True)
plt.legend()
plt.show()
#
```
