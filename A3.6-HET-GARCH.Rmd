---
title: 'TEMA 3: Modelos de regresión con volatilidad variable en el tiempo'
author:
  name: Julián Ramajo, ramajo@unex.es
  affiliation: GRADO EN ESTADÍSTICA | ECONOMETRIA (502243)
subtitle: 'Aplicación 3.6: Relación entre los precios de los carburantes y el precio del petroleo'
output:
  html_document:
    theme: journal
    highlight: haddock
    toc: yes
    toc_depth: 2
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
---

# Objetivo

En esta aplicación se estimará un modelo dinámico para el precio de la gasolina en el que los errores muestran clústeres de volatilidad (heteroscedasticidad autorregresiva condicional, ARCH).

# Código R

```{r, message=FALSE}
# Lectura de librerías
library(tidyverse)
library(zoo)
library(dynlm)
library(nlWaldTest)
library(FinTS)
library(tseries)
library(rugarch)
# Lectura de datos
GASOL_CRUDO <- read_csv("GASOL_CRUDO.csv")
GASOL_CRUDO_ts <- read.zoo(GASOL_CRUDO)
# Gráfica de las series temporales
plot(GASOL_CRUDO_ts)
# Modelo dinámico para el precio de la gasolina (precio minorista)
dyn_model <- dynlm (log(PGASOL) ~ D2008JD + time + L(log(PGASOL), 1:2) + L(log(PCRUDO),0:2), data=GASOL_CRUDO_ts)
summary(dyn_model)
# Estimación de efectos parciales a corto y largo plazo
nlConfint(dyn_model, c("b[6]","(b[6]+b[7]+b[8])/(1-b[4]-b[5])"))
nlWaldtest(dyn_model, "b[6]")
nlWaldtest(dyn_model, "(b[6]+b[7]+b[8])/(1-b[4]-b[5])")
# Contraste de heteroscedasticidad autoregresiva condicional (efectos ARCH)
resid <- as.zoo(dyn_model$residuals)
plot(resid)
plot(resid^2)
summary(dynlm(I(dyn_model$residuals^2) ~ L(I(dyn_model$residuals^2), 1:1)))
ArchTest(dyn_model$residuals, lag = 1)
summary(dynlm(I(dyn_model$residuals^2) ~ L(I(dyn_model$residuals^2), 1:2)))
ArchTest(dyn_model$residuals, lag = 2)
# Modelo GARCH para los errores del modelo
# Librería tseries
resid.ARCH <- garch(resid,c(0,2), trace=FALSE)
summary(resid.ARCH)
hhat_1 <- as.zoo(resid.ARCH$fitted.values[,1]^2)
plot(hhat_1)
# Librería rugarch
resid_GARCH_spec <-  ugarchspec(
  mean.model = list(armaOrder=c(0,0), include.mean = FALSE),
  variance.model = list(model="sGARCH", garchOrder=c(2,0)),
  distribution.model ="norm")
resid_GARCH_fit <- ugarchfit(spec = resid_GARCH_spec, data = resid)
show(resid_GARCH_fit)
hhat_2 <- as.zoo(resid_GARCH_fit@fit$sigma^2)
plot.ts(hhat_2) # ts.plot(resid_GARCH_fit@fit$sigma^2)
# Modo interactivo: permite seleccionar el tipo de gráfica
# plot(resid_GARCH_fit)
plot(resid_GARCH_fit, which=1)
plot(resid_GARCH_fit, which=3)
```

# Código Python

```{python}
# Lectura de librerías
import numpy as np
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf
import statsmodels.stats.api as sms
import matplotlib.pyplot as plt
import statsmodels.stats.diagnostic as smsdiag
from statsmodels.compat import lzip
from arch import arch_model
# Lectura de datos y asignación del índice temporal
GASOL_CRUDO_ts = pd.read_csv("GASOL_CRUDO.csv", parse_dates=['date'], index_col='date')
GASOL_CRUDO_ts.info()
GASOL_CRUDO_ts.head()
GASOL_CRUDO_ts.index
# Asignación del formato semanal (opcional)
date_w = pd.date_range(start = '2000', periods = len(GASOL_CRUDO_ts.index), freq = 'W')
GASOL_CRUDO_ts.index = date_w
GASOL_CRUDO_ts.index
# Gráfica de las series temporales
plt.figure(1)
fig, ax = plt.subplots(4, 1, sharex = True)
ax[0].plot(GASOL_CRUDO_ts.D2008JD)
ax[0].set_ylabel('D2008JD')
ax[1].plot(GASOL_CRUDO_ts.PCRUDO)
ax[1].set_ylabel('PCRUDO')
ax[2].plot(GASOL_CRUDO_ts.PGASOL)
ax[2].set_ylabel('PGASOL')
ax[3].plot(GASOL_CRUDO_ts.time)
ax[3].set_ylabel('time')
plt.show()
# Modelo dinámico para el precio de la gasolina (precio minorista)
GASOL_CRUDO_ts['l_PGASOL'] = np.log(GASOL_CRUDO_ts['PGASOL'])
GASOL_CRUDO_ts['l_PCRUDO'] = np.log(GASOL_CRUDO_ts['PCRUDO'])
formula = 'l_PGASOL ~ D2008JD + time + l_PGASOL.shift(1) + l_PGASOL.shift(2) + l_PCRUDO + l_PCRUDO.shift(1) + l_PCRUDO.shift(2)'
dyn_model = smf.ols(formula, data = GASOL_CRUDO_ts)
lm_dyn_model = dyn_model.fit()
print(lm_dyn_model.summary())
# Estimación de efectos parciales a corto y largo plazo
b = lm_dyn_model.params[0:]
# Multiplicador de corto plazo
b[5].round(3)
# Multiplicador de largo plazo
((b[5]+b[6]+b[7])/(1-b[3]-b[4])).round(3)
# Contraste de heteroscedasticidad autoregresiva condicional (efectos ARCH)
residuals = lm_dyn_model.resid
plt.figure(5)
plt.plot(residuals, label='Residuos')
plt.xlabel('Semana')
plt.grid(True)
plt.legend()
plt.show()
plt.figure(6)
plt.plot(residuals**2, label='Residuos al cuadrado')
plt.xlabel('Semana')
plt.grid(True)
plt.legend()
plt.show()
# Test de Engle
name = ['LM statistic', 'Chi^2 p-val', 'F statistic', 'F p-val']
E_test_1 = smsdiag.het_arch(residuals, nlags=1)
lzip(name,E_test_1)
print(pd.DataFrame([np.round(E_test_1, 3)], columns=name))
E_test_2 = smsdiag.het_arch(residuals, nlags=2)
lzip(name,E_test_2)
print(pd.DataFrame([np.round(E_test_2, 3)], columns=name))
# Modelo GARCH para los errores del modelo
garch_model = arch_model(residuals, mean='Zero', vol='GARCH', p=2, q=0, dist='normal')
mv_garch_model = garch_model.fit()
print(mv_garch_model)
fig = mv_garch_model.plot()
plt.show()
```

