---
title: 'TEMA 3: Variable dependiente discreta o limitada'
author:
  name: Julián Ramajo, ramajo@unex.es
  affiliation: GRADO EN ESTADÍSTICA | ECONOMETRIA (502243)
subtitle: 'Aplicación 3.12: Préstamos hipotecarios. Compra de automóviles. Salario de las mujeres casadas'
output:
  html_document:
    theme: journal
    highlight: haddock
    toc: yes
    toc_depth: 2
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
---

# Variable dependiente discreta (modelos Logit y Probit): Elección entre tipo de interés fijo o variable

## Introducción

En un artículo del año 1987, Dhillon y otros autores estudiaron el conjunto de características personales y financieras que determinan la elección por parte de los individuos de un tipo de interés fijo frente a uno variable a la hora de contratar un préstamo hipotecario. El interés de su trabajo radicaba en contrastar las dos posturas que dominan los planteamientos teóricos sobre el tema: la primera de ellas opina que, de acuerdo con la **hipótesis de mercados eficientes**, las características personales del prestatario no contienen información que no haya sido ya tenida en cuenta por el mercado a la hora de fijar el tipo de interés y, por tanto, sólo las variables de precios y los términos del contrato serían relevantes cuando un individuo elige el tipo de interés que se le aplicará; la segunda escuela de pensamiento supone que existe **información asimétrica**, es decir, dadas las condiciones del mercado, los prestatarios pueden favorecerse no revelando algunas de sus características personales a la hora de firmar el contrato.

El modelo propuesto relaciona la probabilidad de que un individuo elija, dadas sus características personales y las condiciones del mercado, un tipo de interés variable frente a uno fijo para un préstamo hipotecario. Se dispone de una muestra de 78 clientes de un banco hipotecario norteamericano. Del total de observaciones, 46 eligieron un tipo de interés fijo (con vencimiento de 30 años) y 32 un tipo de interés variable (no acotado).

Las variables disponibles para estimar el modelo son las siguientes:

- Variable dependiente: _Y_ toma el valor 1 si el individuo elige un tipo de interés variable y 0 si firma el préstamo a un tipo fijo.

-	Variables explicativas del mercado: _FI_ es el tipo de interés fijo que ofertó el banco, _MARG_ el margen del tipo fijo sobre el tipo de interés variable, _YLD_ la diferencia entre el tipo de interés de las letras del tesoro a 10 años y el tipo de las letras a 1 año (esta variable intenta anticipar el cambio futuro en los tipos de interés a corto plazo), _PTS_ la ratio entre el tipo de interés fijo y el variable, y _MAT_ la ratio entre los vencimientos de los préstamos hipotecarios con tipo fijo y variable.

-	Variables explicativas personales: _BA_ es la edad del prestatario, _BS_ los años de escolarización, _FTB_ una variable ficticia que toma el valor 1 si el prestatario compra vivienda por primera vez y 0 en otro caso, _CB_ una ficticia que toma el valor 1 si existe un co-prestatario y 0 en otro caso, _MC_ una ficticia que toma el valor 1 si el prestatario está casado y 0 si no lo está, _SE_ una ficticia que toma el valor 1 si trabaja por cuenta propia y 0 en otro caso, _MOB_ el número de años que el prestatario lleva residiendo en la dirección actual, _NW_ la riqueza neta, _LA_ los activos líquidos y _STL_ los compromisos económicos del prestatario a corto plazo.

El modelo econométrico general que se estimará tiene la siguiente expresión:

$$Y_{i} = \beta_1 + \beta_2 FI_{i} + \beta_3 MARG_{i} + \beta_4 YLD_{i} + \beta_5 PTS_{i} + \beta_6 MAT_{i} + \beta_7 BA_{i} + \beta_8 BS_{i} + \beta_9 FTB_{i} + \beta_{10} CB_{i} +$$
$$+ \beta_{11} MC_{i} + \beta_{12} MC_{i} + \beta_{13} SE_{i} + \beta_{14} MOB_{i} + \beta_{15} NW_{i} + \beta_{16} LA_{i} + \beta_{17} ST_{i} + e_{i}$$

## Código R

```{r, message=FALSE}
# Lectura de librerías
library(tidyverse)
library(AER)
library(alr4)
library(margins)
# Lectura de datos
PREST_HIP <- read_csv("PREST_HIP.csv")
summary(PREST_HIP)
# Modelo logit
modelo_logit <- glm(Y ~ FI + MARG + YLD + PTS + MAT + BA + BS + FTB + CB + MC + SE + MOB + NW + LA + STL, data=PREST_HIP, family=binomial(link="logit"))
summary(modelo_logit)
# Modelo probit
modelo_probit <- glm(Y ~ FI + MARG + YLD + PTS + MAT + BA + BS + FTB + CB + MC + SE + MOB + NW + LA + STL, data=PREST_HIP, family=binomial(link="probit"))
summary(modelo_probit)
# Significación de las características personales
linearHypothesis ( modelo_logit , c("BA = 0", "BS = 0","FTB = 0","CB = 0","MC = 0","SE = 0","MOB = 0","NW = 0","LA = 0","STL = 0"))
# Modelos logit restringidos
modelo_logit_1 <- glm(Y ~ FI + MARG + YLD + PTS + MAT, data=PREST_HIP, family=binomial(link="logit"))
summary(modelo_logit_1)
linearHypothesis ( modelo_logit_1, c("PTS = 0", "MAT = 0"))
modelo_logit_2 <- glm(Y ~ FI + MARG + YLD, data=PREST_HIP, family=binomial(link="logit"))
summary(modelo_logit_2)
coeftest(modelo_logit_2, vcov. = vcovHC, type = "HC1") # Matriz de convarianzas robusta
# Ajuste del modelo: pseudoR2
pseudoR2 <- 1 - (modelo_logit_2$deviance) / (modelo_logit_2$null.deviance)
pseudoR2
# Fórmula equivalente
modelo_logit_0 <- glm(Y ~ 1, data=PREST_HIP, family=binomial(link="logit"))
1 - logLik(modelo_logit_2)[1]/logLik(modelo_logit_0)[1]
# ANOVA
Anova(modelo_logit_2)
# Tabla de éxito-fracaso (confusion matrix)
table(true=PREST_HIP$Y, predicted=round(fitted(modelo_logit_2)))
# Gráficas de efectos marginales
# Gráfica conjunta
effs <- Effect(c("FI", "MARG","YLD"), modelo_logit_2)
plot(effs, multiline=TRUE, grid=TRUE, lines=c(1, 2, 3), 
     xlab="FI",main="", rotx=45, roty = 45,
     ylab="Prob[Y=1]", rescale.axis=FALSE, rug=FALSE)
# Gráficas separadas
# Función de probabilidad estimada para la variable FI
plot( Y ~ FI, PREST_HIP, xlab="FI", ylab="Prob", ylim=c(0,1))
FInew <- seq(10, 20, length=78)
lines(FInew, predict(modelo_logit_2, newdata=data.frame(FI=FInew, MARG=rep(mean(PREST_HIP$MARG), 78), YLD=rep(mean(PREST_HIP$YLD), 78)), type="response"), lwd=1.5)
grid(col="gray", lty="solid")
# Función de probabilidad estimada para la variable MARG
plot( Y ~ MARG, PREST_HIP, xlab="MARG", ylab="Prob", ylim=c(0,1))
MARGnew <- seq(-1, 6, length=78)
lines(MARGnew, predict(modelo_logit_2, newdata=data.frame(FI=rep(mean(PREST_HIP$FI), 78), MARG=MARGnew, YLD=rep(mean(PREST_HIP$YLD), 78)), type="response"), lwd=1.5)
grid(col="gray", lty="solid")
# Función de probabilidad estimada para la variable YLD
plot( Y ~ YLD, PREST_HIP, xlab="YLD", ylab="Prob", ylim=c(0,1))
YLDnew <- seq(1, 2.5, length=78)
lines(YLDnew, predict(modelo_logit_2, newdata=data.frame(FI=rep(mean(PREST_HIP$FI), 78), MARG=rep(mean(PREST_HIP$MARG), 78), YLD=YLDnew), type="response"), lwd=1.5)
grid(col="gray", lty="solid")
# Efecto marginal en la media de las variables explicativas
EMM_logit = mfx::logitmfx(formula = modelo_logit_2$formula, data = modelo_logit_2$data, atmean = TRUE)
print(EMM_logit[[1]])
# Efecto marginal promedio
EMP_logit = mfx::logitmfx(formula = modelo_logit_2$formula, data = modelo_logit_2$data, atmean = FALSE)
print(EMP_logit[[1]])
# Forma alternativa del EMP
margins(modelo_logit_2)
```

## Código Python

```{python, message=FALSE}
# Lectura de librerías
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf
import statsmodels.api as sm
# Lectura de datos
PREST_HIP = pd.read_csv("PREST_HIP.csv")
PREST_HIP.describe()
# Modelo logit
modelo_logit = smf.glm("Y ~ 1 + FI + MARG + YLD", data = PREST_HIP, 
family = sm.families.Binomial(link = sm.genmod.families.links.logit())).fit()
print(modelo_logit.summary())
# Formulación alternativa del modelo logit
modelo_logit = smf.logit("Y ~ 1 + FI + MARG + YLD", data = PREST_HIP).fit()
print(modelo_logit.summary())
# Modelo probit
modelo_probit = smf.probit("Y ~ 1 + FI + MARG + YLD", data = PREST_HIP).fit()
print(modelo_probit.summary())
# Tabla de éxito-fracaso
tmp_out_1 = modelo_logit.pred_table(threshold = 0.5)
print(pd.DataFrame(tmp_out_1, columns = ["Predichos 0", "Predichos 1"], index = ["Observados 0", "Observados 1"]))
# Formulación alternativa
from sklearn import metrics
predicted_probs_logit = modelo_logit.predict(exog = PREST_HIP)
tmp_out_2 = metrics.confusion_matrix(modelo_logit.model.endog, 
                                   np.where(predicted_probs_logit >= 0.5, 1, 0))
print(pd.DataFrame(tmp_out_2, 
                   columns = ["Predichos 0", "Predichos 1"],
                   index = ["Observados 0", "Observados 1"]))
# Precisión global del modelo en términos de predicción
tmp_accuracy = metrics.accuracy_score(modelo_logit.model.endog,
                       np.where(predicted_probs_logit >= 0.5, 1, 0))
print(np.round(tmp_accuracy,4)) 
# Efecto marginal en la media de las variables explicativas
EMM_logit = modelo_logit.get_margeff(at = "mean")
print(EMM_logit.summary())
# Efecto marginal promedio
EMP_logit = modelo_logit.get_margeff(at = "overall")
print(EMP_logit.summary())
```

# Variable dependiente limitada (valores censurados -> modelo Tobit): Compra de automóviles

## Introducción

En un trabajo encargado por una asociación de fabricantes de automóviles, se estimó un modelo microeconométrico en el que se relacionaba el gasto en automóviles realizado por las familias que componían una muestra representativa con algunas características socioeconómicas de las mismas.
La ecuación de comportamiento especificada fue la siguiente:
$$GAUT_{i} = \beta_1 + \beta_2 Y_{i} + \beta_3 HIJOSM18_{i} + \beta_4 EDAD_{i} + e_{i}$$
donde GAUT es el gasto familiar efectuado en la adquisición de automóviles en el último año, Y la renta familiar total del último ejercicio fiscal, HIJOSM18 el número de hijos con edades inferiores a dieciocho años y EDAD la edad del cabeza de familia.

## Código R

```{r, message=FALSE}
# Lectura de librerías
library(tidyverse)
library(censReg) # http://www.sampleselection.org/
# Lectura de datos
AUTOS <- read_csv("AUTOS.csv")
summary(AUTOS)
# Datos censurados: modelo Tobit 
# Librería censReg (https://cran.r-project.org/web/packages/censReg/vignettes/censReg.pdf)
modelo_tobit_1 <- censReg(GAUT ~ EDAD + HIJOSM18 + Y, data = AUTOS)
summary(modelo_tobit_1)
# Efectos marginales
# Evaluados en un valor concreto de las var. explicativas (media de las variables en este caso)
margEff(modelo_tobit_1,xValues = c(1,mean(AUTOS$EDAD),mean(AUTOS$HIJOSM18),mean(AUTOS$Y)))
# Efectos marginales promedio
margEff(modelo_tobit_1)
# Librería VGAM (https://www.stat.auckland.ac.nz/~yee/VGAM/)
library(VGAM)
modelo_tobit_2 <- vglm(GAUT ~ EDAD + HIJOSM18 + Y, family = tobit, data = AUTOS)
summary(modelo_tobit_2)
```

## Código Python

```{r}
library(reticulate)
py_run_file("tobit.py")
```

```{python}
# Lectura de datos
AUTOS = pd.read_csv("AUTOS.csv")
AUTOS.describe()
# Estimación del modelo Tobit con los datos de la aplicación
y = AUTOS.GAUT
x = AUTOS.drop(['GAUT'], axis=1)
cens = pd.Series(np.zeros((len(y),)))
cens[y==0] = -1
cens.value_counts()
modelo_tobit = TobitModel()
res = modelo_tobit.fit(x, y, cens, verbose=False)
res.coef_
res.sigma_
```

# Variable dependiente limitada (truncamiento selectivo -> modelo Heckit de selección muestral): Salarios de las mujeres casadas en el Reino Unido

## Introducción

En esta aplicación se estima una ecuación Minceriana de salarios para las mujeres casadas basada en una investigación de Thomas A. Mroz del año 1987 para UK. El modelo propuesto es el siguiente:
$$log(SALARIO_{i}) = \beta_1 + \beta_2 EDUC_{i} + \beta_3 EXPER_{i} + e_{i}$$
donde SALARIO representa el salario por hora trabajada observado, EDUC el nivel de educación y EXPER el nivel de experiencia.
Al realizar una encuesta a una muestra de N = 753 mujeres casadas, representativa de la población femenina con ese estado civil en UK, preguntándoles entre otras cosas por su salario, muchas de ellas (325 mujeres) respondieron que esa cuestión no era relevante en su caso, ya que eran “amas de casa” (población no activa) y no recibían remuneración alguna por ese trabajo. Solo se observaron datos sobre salarios de mercado para aquellas mujeres (n = 428) que participaban en la fuerza de trabajo.

## Código R

```{r, message=FALSE}
# Lectura de librerías
library(tidyverse)
library(sampleSelection) # http://www.sampleselection.org/
# Lectura de datos
SAL_MUJ <- read_csv("SAL_MUJ.csv")
summary(SAL_MUJ)
# Modelo Heckit (https://cran.r-project.org/web/packages/sampleSelection/vignettes/selection.pdf)
modelo_heckit <- selection(PMT ~ EDUC + EDAD + HIJOSMEN + TMIMP, log(SALARIO) ~ EDUC + EXPER, data=SAL_MUJ, method="ml")
summary(modelo_heckit)
```

## Código Python

```{python, message=FALSE}
# Lectura de librerías
import numpy as np
import pandas as pd
import scipy.stats as stats
import statsmodels.api as sm
import statsmodels.formula.api as smf
# Lectura de datos
SAL_MUJ = pd.read_csv("SAL_MUJ.csv")
SAL_MUJ.describe()
# Modelo Heckit
# Estimación en dos pasos (menos eficiente que la estimación ML)
# Realizando las regresiones "manualmente"
# Paso 1 (modelo Probit para todas las observaciones)
reg_probit = smf.probit(formula='PMT ~ EDUC + EDAD + HIJOSMEN + TMIMP', data=SAL_MUJ)
res_probit = reg_probit.fit(disp=0)
print(res_probit.summary())
pred_PMT = res_probit.fittedvalues
SAL_MUJ['inv_mills'] = stats.norm.pdf(pred_PMT) / stats.norm.cdf(pred_PMT)
# Paso 2 (regresión truncada con las observaciones seleccionadas y la inversa de la razón de Mills como variable explicativa adicional)
reg_heckit = smf.ols(formula='np.log(SALARIO) ~ EDUC + EXPER + inv_mills', subset=(SAL_MUJ['PMT'] == 1), data=SAL_MUJ).fit(cov_type='HAC', cov_kwds={'maxlags':6,'use_correction':True})
print(reg_heckit.summary())
# Usando el script heckman.py (statsmodels): errores estándar correctos
SAL_MUJ['lSALARIO'] = np.log(SAL_MUJ['SALARIO'])
lSALARIO = SAL_MUJ['lSALARIO'].copy() # Variable dependiente regresión truncada
Xs = SAL_MUJ[['EDUC', 'EXPER']] # Variables exógenas regresión truncada
X = sm.add_constant(Xs, prepend = True)
Ws = SAL_MUJ[['EDUC', 'EDAD', 'HIJOSMEN', 'TMIMP']] # Variables exógenas ecuación selección
W = sm.add_constant(Ws, prepend = True)
import heckman as heckman   # exec(open("heckman.py").read())
res = heckman.Heckman(lSALARIO, X, W).fit(method='twostep')
print(res.summary()) 
```
