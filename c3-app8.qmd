---
engine: knitr
excerpt: ""
draft: false
format: 
  html:
    theme: simplex
    self-contained: true
    max-width: 1920px
    code-fold: show
    code-tools: true
    highlight-style: atom-one-dark
    code-block-bg: "#282c34"
---

```{css, echo = FALSE}
.justify { text-align: justify !important }
```

::: justify
# Aplicación 3.8 (Dependencia espacial en los datos - Econometría espacial): Precio de la vivienda en el condado de Lucas [Ohio, Estados Unidos] {.unnumbered}

En esta aplicación se introducen varios conceptos de econometría espacial, se realiza un análisis de tipo exploratorio con la base de datos utilizada, y también se proponen modelos de regresión en los que las variables de dicho modelo y/o los errores del mismo presentan autocorrelación espacial.
:::

## Código R {.unnumbered}

```{r}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
library(tidyverse)
library(sf) # https://r-spatial.github.io/sf/index.html
library(geojsonsf)
library(spdep)
library(spatialreg)
library(sp)

# Lectura de datos
house_sf <- geojson_sf("data/Ohio_USA.geojson")
class(house_sf)
str(house_sf)
summary(house_sf)

# Gráficas: representación de datos espaciales
plot(house_sf$price)
plot(house_sf[3])
ggplot(house_sf) + geom_sf(aes(fill=price))+ theme_bw()

# Estadística espacial exploratoria (ESDA)
# Información sobre las coordenadas (longitud y latitud) de los datos
coords <- coordinates(house)
# Construcción de matrices de pesos espaciales: vecinos más próximos (k=6, mediana de vecinos)
house.6nn <- knearneigh(coords, k=6) 
house.6nn.nb <- knn2nb(house.6nn)
# Gráficos de vecinos
plot(st_geometry(house_sf)) 
plot(house.6nn.nb, coords, add=TRUE, col="red")
# Matriz espacial W estandarizada por filas
house.6nn.w <- nb2listw(neighbours=house.6nn.nb, style="W")
# Estadísticos de autocorrelación espacial
# Global
moran.test(house_sf$price, listw=house.6nn.w)
geary.test(house_sf$price, listw=house.6nn.w)
# Local
LocalI <- as.data.frame(localmoran(house_sf$price, listw=house.6nn.w))
str(LocalI)
moran.plot(house_sf$price, listw=house.6nn.w) 
# Clusters locales
house_LocalI_sf <- bind_cols(house_sf,LocalI)
plot(house_LocalI_sf["Z.Ii"])

# Modelos econométricos espaciales
form <- formula(log(price) ~ age + log(lotsize) + rooms)
# Modelo lineal (LM) [estimación MCO]
m1 <- lm(formula=form, data=house_sf)
summary(m1)
# Modelo con retardo espacial (SLM) [estimación S2SLS]
m2 <- stsls(formula=form, data=house_sf, listw=house.6nn.w)
summary(m2)
# Modelo con errores espaciales (SEM) [estimación GMM]
m3 <- GMerrorsar(formula=form, data=house_sf, listw=house.6nn.w)
summary(m3)
# Modelo combinado (SAC -> SLM + SEM) [estimación GS2SLS]
m4 <- gstsls(formula=form, data=house_sf, listw=house.6nn.w)
summary(m4)
```

## Código Python {.unnumbered}

```{python}
#| eval: true
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
import warnings
warnings.filterwarnings("ignore")
import matplotlib.pylab as plt
plt.rcParams['figure.dpi'] = 300
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import FormatStrFormatter
plt.style.use('ggplot')
from pylab import rcParams
import matplotlib as mpl
mpl.rcParams['figure.dpi'] = 300
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
import geopandas as gpd
import libpysal
from libpysal  import weights
import esda
from esda.moran import Moran, Moran_Local
import splot
from splot.esda import moran_scatterplot, plot_moran, lisa_cluster, plot_local_autocorrelation
from splot.libpysal import plot_spatial_weights
from giddy.directional import Rose
import statsmodels.api as sm
import statsmodels.formula.api as smf
import spreg

# Lectura de datos
house = gpd.read_file("data/Ohio_USA.geojson")
house.head(5)

# Estadística descriptiva
house.describe().round(2)

# Mapas básicos
house.plot('price', legend = True)
plt.show()
# Vecinos geográficos y matriz de pesos espaciales 
W = weights.KNN.from_dataframe(house, k=6)
# Estandarización por filas (Row-standardized W)
W.transform = 'r'
plot_spatial_weights(W, house)
plt.show()
# Retardos espaciales
house["Wprice"] = weights.lag_spatial(W, house["price"])
house[["price", "Wprice"]].round(2)
# Dependencia espacial global
px.scatter(
    house,
    x="price",
    y="Wprice",
    hover_name="yrbuilt",
    labels = dict(price  = "Precio de venta de la vivienda",
                  Wprice = "Precio promedio de venta de los vecinos"),
    trendline="ols",
    marginal_x="box",
    marginal_y="box")
plt.show()
globalMoran = Moran(house['price'], W)
print(globalMoran.I)
print(globalMoran.p_sim)
moran_scatterplot(globalMoran, aspect_equal=True, zstandard=True)
plt.show()
# Dependencia espacial local
localMoran = Moran_Local(house['price'], W, permutations = 999, seed=12345)
localMoran.p_sim
moran_scatterplot(localMoran, p=0.20, zstandard =False) # Nota: p-valor=0.20
plt.show()
lisa_cluster(localMoran, house, p=0.20)
plt.show()

# Modelos econométricos espaciales
# Operaciones con variables
house['l_price']=house['price'].map(lambda x:np.log(x))
house['l_lotsize']=house['lotsize'].map(lambda x:np.log(x))
variable_names = ['age', 'l_lotsize', 'rooms']
# Modelo lineal (LM) [estimación MCO]
m1 = spreg.OLS(
    # Var. dep.
    house[['l_price']].values, 
    # Var. expl.
    house[variable_names].values,
    # 
    name_y='l_price', 
    # 
    name_x=variable_names
)
print(m1.summary)
knn = weights.KNN.from_dataframe(house, k=6)
lag_residual = weights.spatial_lag.lag_spatial(knn, m1.u)
ax = sns.regplot(x = m1.u.flatten(), y = lag_residual.flatten(),ci=None)
ax.set_xlabel('Residuals ($u$)')
ax.set_ylabel('Spatial lag of residuals ($Wu$)')
plt.show()
# Modelo con retardo espacial (SLM) [estimación S2SLS]
m2 = spreg.GM_Lag(
    # Var. dep.
    house[['l_price']].values, 
    # Var. expl.
    house[variable_names].values,
    # Matriz W
    w=knn, 
    # 
    name_y='l_price', 
    # 
    name_x=variable_names
)
print(m2.summary)
# Modelo con errores espaciales (SEM) [estimación GMM]
m3 = spreg.GM_Error(
    # Var. dep.
    house[['l_price']].values, 
    # Var. expl.
    house[variable_names].values,
    # Matriz W
    w=knn, 
    #  
    name_y='l_price', 
    # 
    name_x=variable_names
)
print(m3.summary)
# Modelo combinado (SAC -> SLM + SEM) [estimación GMM]
m4 = spreg.GM_Combo(
    # Var. dep.
    house[['l_price']].values, 
    # Var. expl.
    house[variable_names].values,
    # Matriz W
    w=knn, 
    # 
    name_y='l_price', 
    # 
    name_x=variable_names
)
print(m4.summary)
```
