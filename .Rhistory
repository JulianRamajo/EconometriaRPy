gapminder <- read_delim("GAPMINDER.csv", ";", escape_double = FALSE, trim_ws = TRUE)
head(gapminder)
setwd("~/Dropbox/Mi Mac (Mac Pro de Julián)/Documents/GitHub/EconMetricsRPy")
gapminder2 <- read_delim("GAPMINDER.csv", ";", escape_double = FALSE, trim_ws = TRUE)
head(gapminder2)
gapminder <- read_delim("GAPMINDER.csv", ";", escape_double = FALSE, trim_ws = TRUE)
head(gapminder)
# ggplot2
ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +
geom_point()
ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +
geom_point(aes(size = pop, col = continent), alpha = 0.3)
#
p = ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp))
p +
geom_point(alpha = 0.3)  +
geom_smooth(method = "loess")
p +
geom_point(aes(size = pop, col = continent), alpha = 0.3)  +
geom_smooth(method = "loess")
#
ggplot(data = gapminder) +
geom_density(aes(x = gdpPercap), alpha=0.3)
#
ggplot(data = gapminder) +
geom_density(aes(x = gdpPercap, fill = continent), alpha=0.3)
p2 =
p +
geom_point(aes(size = pop, col = continent), alpha = 0.3) +
scale_color_brewer(name = "Continent", palette = "Set1") + ## Diferente  escala de colores
scale_size(name = "Population", labels = scales::comma) + ## Diferentes escala de puntos
scale_x_log10(labels = scales::dollar) + ## Escala logarítmica en el eje X y unidades de $
labs(x = "Log (GDP per capita)", y = "Life Expectancy") + ## Títulos en los ejes
theme_minimal() ## minimal (b&w) plot theme
p2
if (!require("pacman")) install.packages("pacman")
pacman:: p_load(hrbrthemes, gganimate)
library(hrbrthemes)
p2 + theme_modern_rc() + geom_point(aes(size = pop, col = continent), alpha = 0.2)
library(gganimate)
ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
geom_point(alpha = 0.7, show.legend = FALSE) +
scale_colour_manual(values = country_colors) +
scale_size(range = c(2, 12)) +
scale_x_log10() +
facet_wrap(~continent) +
# Here comes the gganimate specific bits
labs(title = 'Year: {frame_time}', x = 'GDP per capita', y = 'life expectancy') +
transition_time(year) +
ease_aes('linear')
library(gganimate)
ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
geom_point(alpha = 0.7, show.legend = FALSE) +
scale_colour_manual(values = country_colors) +
scale_size(range = c(2, 12)) +
scale_x_log10(labels = scales::dollar) +
facet_wrap(~continent) +
# gganimate bits
labs(title = 'Year: {frame_time}', x = 'Log (GDP per capita)', y = 'Life expectancy') +
transition_time(year) +
ease_aes('linear')
View(gapminder)
version$version.string
RStudio.Version()$version
# Regresión
#
model_1 <- lm(lifeExp ~ gdpPercap, data=gapminder)
summary(model_1)
par(mar = c(4, 4, 1, .1)) ## Just for nice plot margins on this slide deck
plot(gapmined$gdpPercap, gapmined$lifeExp)
abline(model_1, col = "red")
par(mar = c(4, 4, 1, .1))
plot(gapminer$gdpPercap, gapminer$lifeExp)
abline(model_1, col = "red")
par(mar = c(4, 4, 1, .1))
plot(gapminder$gdpPercap, gapminder$lifeExp)
abline(model_1, col = "red")
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
geom_smooth(method = "lm", col = "red") +
geom_point()
ggplot(data = gapminder, aes(x = log(gdpPercap), y = lifeExp)) +
geom_smooth(method = "lm", col = "red") +
geom_point()
#
model_3 <- lm(lifeExp ~ log(gdpPercap) + year, data=gapminder)
summary(model_3)
model_3 %>%
gg_diagnose(plot.all=TRUE,boxcox=TRUE)
ggplot(data = gapminder, aes(x = log(gdpPercap), y = lifeExp)) +
geom_smooth(method = "lm", col = "red") +
geom_point()
ggplot(data = gapminder, aes(x = year, y = lifeExp)) +
geom_smooth(method = "lm", col = "red") +
geom_point()
ggplot(data = gapminder, aes(x = log(gdpPercap), y = lifeExp)) +
geom_smooth(method = "lm", col = "red") +
geom_point()
library(tidyverse)
gapminder <- read_delim("GAPMINDER.csv", ";", escape_double = FALSE, trim_ws = TRUE)
head(gapminder)
library(tidyverse)
gapminder <- read_delim("GAPMINDER.csv", ";", escape_double = FALSE, trim_ws = TRUE)
head(gapminder)
#
# Operaciones básicas del Tidyverse
#
# Gramática de gráficas (ggplot2)
#
ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +
geom_point()
#
ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +
geom_point(aes(size = pop, col = continent), alpha = 0.3)
#
p = ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp))
p +
geom_point(alpha = 0.3)  +
geom_smooth(method = "loess")
#
p +
geom_point(aes(size = pop, col = continent), alpha = 0.3)  +
geom_smooth(method = "loess")
#
ggplot(data = gapminder) +
geom_density(aes(x = gdpPercap), alpha=0.3)
#
ggplot(data = gapminder) +
geom_density(aes(x = gdpPercap, fill = continent), alpha=0.3)
#
p2 =
p +
geom_point(aes(size = pop, col = continent), alpha = 0.3) +
scale_color_brewer(name = "Continent", palette = "Set1") + ## Diferente  escala de colores
scale_size(name = "Population", labels = scales::comma) + ## Diferentes escala de puntos
scale_x_log10(labels = scales::dollar) + ## Escala logarítmica en el eje X y unidades de $
labs(x = "Log (GDP per capita)", y = "Life Expectancy") + ## Títulos en los ejes
theme_minimal() ## minimal (b&w) plot theme
p2
#
library(gganimate)
ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
geom_point(alpha = 0.7, show.legend = FALSE) +
scale_colour_manual(values = country_colors) +
scale_size(range = c(2, 12)) +
scale_x_log10(labels = scales::dollar) +
facet_wrap(~continent) +
# gganimate bits
labs(title = 'Year: {frame_time}', x = 'Log (GDP per capita)', y = 'Life expectancy') +
transition_time(year) +
ease_aes('linear')
library(gganimate)
ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
geom_point(alpha = 0.7, show.legend = FALSE) +
scale_colour_manual(values = country_colors) +
scale_size(range = c(2, 12)) +
scale_x_log10(labels = scales::dollar) +
facet_wrap(~continent) +
labs(title = 'Year: {frame_time}', x = 'Log (GDP per capita)', y = 'Life expectancy') +
transition_time(year) +
ease_aes('linear')
library(gganimate)
ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
geom_point(alpha = 0.7, show.legend = FALSE) +
# scale_colour_manual(values = country_colors) +
scale_size(range = c(2, 12)) +
scale_x_log10(labels = scales::dollar) +
facet_wrap(~continent) +
labs(title = 'Year: {frame_time}', x = 'Log (GDP per capita)', y = 'Life expectancy') +
transition_time(year) +
ease_aes('linear')
knitr::opts_chunk$set(echo = TRUE)
install.packages("reticulate")
library(reticulate)
repl_python
repl_python()
conda_list()
print(reticulate::py_config())
library(reticulate)
repl_python()
miniconda_update()
conda_install("plotnine")
repl_python()
conda_remove("plotnine")
conda_list()
conda_version()
install_miniconda(update=TRUE)
install_miniconda(update=TRUE, force=TRUE)
miniconda_update()
miniconda_path()
py_install("plotnine")
?install_miniconda()
library(tidyverse)
cps <- read_csv("MORG14_USA.csv")
cps <- cps %>% filter(age>=24 & age<=64 & uhours>=20 & earnwke>0 & grade92>=44)
glimpse(cps)
rm()
rm(cps)
library(reticulate)
repl_python()
py_install("xlrd")
repl_python()
install.packages(c("autostsm", "BGVAR", "bookdown", "forestplot", "future.apply", "gss", "infer", "modelsummary", "Quandl", "rbibutils", "readr", "rgeoda", "RPostgreSQL", "servr", "survival", "svars", "vroom", "x13binary", "xfun"))
library(tidyverse)
#
library(readxl)
macro <- read_excel("APT_MICROSOFT.xls")
head(macro)
tail(macro)
#
macro$dspread = c(NA,diff(macro$BMINUSA))
macro$dcredit = c(NA,diff(macro$CCREDIT))
macro$dprod = c(NA,diff(macro$INDPRO))
macro$dmoney = c(NA,diff(macro$M1SUPPLY))
macro$inflation = c(NA,100*diff(log(macro$CPI)))
macro$rterm = c(NA,diff(macro$USTB10Y-macro$USTB3M))
macro$dinflation = c(NA,100*diff(macro$inflation))
macro$r_msoft = c(NA,100*diff(log(macro$MICROSOFT)))
macro$r_sp = c(NA,100*diff(log(macro$SANDP)))
macro$er_sp = c(NA,100*diff(log(macro$SANDP)))-macro$USTB3M/12
macro$er_msoft = c(NA,100*diff(log(macro$MICROSOFT)))-macro$USTB3M/12
#
APT_msoft = lm(er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm, data = macro)
summary(APT_msoft)
#
library(car)
linearHypothesis(APT_msoft,c("dprod=0","dcredit=0","dmoney=0","dspread=0"))
#
# DIAGNOSIS DEL MODELO
#
# Heteroscedasticidad
#
# Gráfico de errores estimados (residuos)
plot(macro$Date[-(1:2)],APT_msoft$residuals,type = "l",xlab="",ylab="")
# Test de Breusch-Pagan de heteroscedasticidad aditiva
library(lmtest)
bptest(formula(APT_msoft),data = macro,studentize = F)
bptest(formula(APT_msoft),data = macro,studentize = T)
# Corrección de la matriz de covarianzas
library(sandwich)
coeftest(APT_msoft,vcov. = vcovHC(APT_msoft,type="HC1")) # White
coeftest(APT_msoft,vcov. = NeweyWest(APT_msoft,lag = 6,adjust = T,prewhite = F)) # Newey-West
#
# Autocorrelación
#
# Test de Durbin-Watson
dwtest(APT_msoft)
# Test de Breuscgh-Godfrey
bgtest(APT_msoft,order = 10)
#
# Heteroscedasticidad autorregresiva condicional (ARCH)
#
library(FinTS)
ArchTest(APT_msoft$residuals , lags = 1)
# Normalidad  de los errores
#
# Histograma de los residuos
hist(APT_msoft$residuals,main = "")
box()
# Estadísticos de normalidad
library(moments)
skewness(APT_msoft$residuals)
kurtosis(APT_msoft$residuals)
jarque.test(APT_msoft$residuals)
agostino.test(APT_msoft$residuals)
anscombe.test(APT_msoft$residuals)
# Sucesos especiales (uso de variables ficticias para modelizar la presencia de 'algunos' outliers)
plot(macro$Date[-(1:2)],APT_msoft$residuals,type = "l", col="red",xlab="",ylab="")
lines(macro$Date[-(1:2)],APT_msoft$fitted.values)
legend("bottomright",c("Residuals","Fitted"), col = c("red","black"),lty=1)
#
macro$Date = as.Date(macro$Date)
macro$APR2000DUM = as.integer(macro$Date == as.Date("2000-04-01"))
macro$DEC2000DUM = as.integer(macro$Date == as.Date("2000-12-01"))
APT_msft_dummy = lm(er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney+ dspread + rterm +
APR2000DUM + DEC2000DUM, data = macro)
summary(APT_msft_dummy)
# Períodos especiales
require(lubridate)
macro$JANDUM = as.integer(month(macro$Date) == 1)
summary(lm(er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm +
APR2000DUM + DEC2000DUM + JANDUM, data = macro))
#
# Multicolinealidad
#
library(car)
library(corrplot)
# Matriz de correlaciones
cor(macro[-(1:2),c("dprod","dcredit","dinflation","dmoney","dspread","rterm")])
corrplot(cor(macro[-(1:2),c("dprod","dcredit","dinflation","dmoney","dspread","rterm")]))
# FIVs
vif(APT_msoft)
#
# Forma funcional
#
# Test de Ramsey
resettest(APT_msoft,power = 2:3)
#
# Estabilidad de los parámetros
#
library(strucchange)
sbtest = Fstats(formula(APT_msoft),data = macro) # Recorte del 15% en ambos lados de la muestra (15% de 383 obs. -> 57)
# Test de Chow con punto de ruptura conocido
JAN1996 = match(as.Date("1996-01-01"),macro$Date)
chow = sbtest$Fstats[JAN1996-2-57] # Punto ruptura (breakpoint): 2 NAs + 57 -> 59
chow
1-pchisq(chow,sbtest$nreg)
# Test de Chow recursivo (punto de ruptura desconocido)
sctest(sbtest)
bp = which.max(sbtest$Fstats)+59
macro$Date[bp]
# Estimación recursiva y test CUSUM
# Parámetros recursivos
beta = NULL # variable para introducir en cada paso el beta y su error estándar estimados
for (t in 20:nrow(macro)){
lr = summary(lm(formula(APT_msoft), data = macro[3:t,]))
beta = rbind(beta,lr$coefficients["er_sp",1:2])
}
x_axis = macro$Date[20:nrow(macro)]
plot(x_axis,beta[,1],type = "l",ylim = c(0,3),xlab="",ylab="Beta")
lines(x_axis,beta[,1]+2*beta[,2],lty="dashed")
lines(x_axis,beta[,1]-2*beta[,2],lty="dashed")
# Test CUSUM
plot(efp(APT_msoft,data=macro))
#
library(reticulate)
repl_python()
library(reticulate)
repl_python()
library(tidyverse)
#
library(readxl)
macro <- read_excel("APT_MICROSOFT.xls")
head(macro)
tail(macro)
#
macro$dspread = c(NA,diff(macro$BMINUSA))
macro$dcredit = c(NA,diff(macro$CCREDIT))
macro$dprod = c(NA,diff(macro$INDPRO))
macro$dmoney = c(NA,diff(macro$M1SUPPLY))
macro$inflation = c(NA,100*diff(log(macro$CPI)))
macro$rterm = c(NA,diff(macro$USTB10Y-macro$USTB3M))
macro$dinflation = c(NA,100*diff(macro$inflation))
macro$r_msoft = c(NA,100*diff(log(macro$MICROSOFT)))
macro$r_sp = c(NA,100*diff(log(macro$SANDP)))
macro$er_sp = c(NA,100*diff(log(macro$SANDP)))-macro$USTB3M/12
macro$er_msoft = c(NA,100*diff(log(macro$MICROSOFT)))-macro$USTB3M/12
#
# ESTIMACIÓN MCO DEL MODELO
#
APT_msoft = lm(er_msoft ~ er_sp + dprod + dcredit + dinflation + dmoney + dspread + rterm, data = macro)
summary(APT_msoft)
View(macro)
#
library(car)
library(corrplot)
# Matriz de correlaciones
cor(macro[-(1:2),c("er_sp","dprod","dcredit","dinflation","dmoney","dspread","rterm")])
corrplot(cor(macro[-(1:2),c("er_sp","dprod","dcredit","dinflation","dmoney","dspread","rterm")]))
repl_python()
install.packages("ggalt")
library(ggplot2)
library(gridExtra)
library(ggalt)
library(scales)
p <- ggplot(msleep, aes(bodywt, brainwt)) + geom_point()
# add identity scale minor ticks on y axis
p + annotation_ticks(sides = 'l')
p
p +annotation_logticks(sides = 'l')
p +annotation_logticks(sides = 'bl')
p +annotation_logticks(sides = 'l')
# add identity scale minor ticks on x,y axis
p + annotation_logticks(sides = 'lb')
# log10 scale
p1 <- p + scale_x_log10()
# add minor ticks on both scales
p1 + annotation_ticks(sides = 'lb', scale = c('identity','log10'))
# log10 scale
p1 <- p + scale_x_log10()
# add minor ticks on both scales
p1 + annotation_logticks(sides = 'lb', scale = c('identity','log10'))
library(ggplot2)
library(gridExtra)
library(ggalt)
library(scales)
set.seed(1492)
data(geyser, package="MASS")
ggplot(geyser, aes(x=duration)) +
stat_bkde(alpha=1/2)
rm(p)
rm(p1)
View(geyser)
set.seed(1492)
dat <- data.frame(cond = factor(rep(c("A","B"), each=200)),
rating = c(rnorm(200),rnorm(200, mean=.8)))
ggplot(dat, aes(x=rating, color=cond)) + geom_bkde(fill="#00000000")
View(dat)
ggplot(dat, aes(x=rating, fill=cond)) + geom_bkde(alpha=0.3)
m <- ggplot(faithful, aes(x = eruptions, y = waiting)) +
geom_point() +
xlim(0.5, 6) +
ylim(40, 110)
m + geom_bkde2d(bandwidth=c(0.5, 4))
m + stat_bkde2d(bandwidth=c(0.5, 4), aes(fill = ..level..), geom = "polygon")
df <- data.frame(trt=LETTERS[1:5], l=c(20, 40, 10, 30, 50), r=c(70, 50, 30, 60, 80))
ggplot(df, aes(y=trt, x=l, xend=r)) +
geom_dumbbell(size=3, color="#e3e2e1",
colour_x = "#5b8124", colour_xend = "#bad744",
dot_guide=TRUE, dot_guide_size=0.25) +
labs(x=NULL, y=NULL, title="ggplot2 geom_dumbbell with dot guide") +
theme_minimal() +
theme(panel.grid.major.x=element_line(size=0.05)) +
theme(panel.grid.major.y=element_blank())
library(ggplot2)
library(gridExtra)
library(ggalt)
library(scales)
df <- read.csv(text="category,pct
Other,0.09
South Asian/South Asian Americans,0.12
Interngenerational/Generational,0.21
S Asian/Asian Americans,0.25
Muslim Observance,0.29
Africa/Pan Africa/African Americans,0.34
Gender Equity,0.34
Disability Advocacy,0.49
European/European Americans,0.52
Veteran,0.54
Pacific Islander/Pacific Islander Americans,0.59
Non-Traditional Students,0.61
Religious Equity,0.64
Caribbean/Caribbean Americans,0.67
Latino/Latina,0.69
Middle Eastern Heritages and Traditions,0.73
Trans-racial Adoptee/Parent,0.76
LBGTQ/Ally,0.79
Mixed Race,0.80
Jewish Heritage/Observance,0.85
International Students,0.87", stringsAsFactors=FALSE, sep=",", header=TRUE)
gg <- ggplot(df, aes(y=reorder(category, pct), x=pct))
gg <- gg + geom_lollipop(point.colour="steelblue", point.size=2, horizontal=TRUE)
gg <- gg + scale_x_continuous(expand=c(0,0), labels=percent,
breaks=seq(0, 1, by=0.2), limits=c(0, 1))
gg <- gg + labs(x=NULL, y=NULL,
title="SUNY Cortland Multicultural Alumni survey results",
subtitle="Ranked by race, ethnicity, home land and orientation\namong the top areas of concern",
caption="Data from http://stephanieevergreen.com/lollipop/")
gg <- gg + theme_minimal()
gg <- gg + theme(panel.grid.major.y=element_blank())
gg <- gg + theme(panel.grid.minor=element_blank())
gg <- gg + theme(axis.line.y=element_line(color="#2b2b2b", size=0.15))
gg <- gg + theme(axis.text.y=element_text(margin=margin(r=0, l=0)))
gg <- gg + theme(plot.margin=unit(rep(30, 4), "pt"))
gg <- gg + theme(plot.title=element_text(face="bold"))
gg <- gg + theme(plot.subtitle=element_text(margin=margin(b=10)))
gg <- gg + theme(plot.caption=element_text(size=8, margin=margin(t=10)))
gg
View(df)
library(ggalt)
#> Loading required package: ggplot2
library(proj4)
world <- ggplot2::map_data("world")
world <- world[world$region != "Antarctica",]
gg <- ggplot()
gg <- gg + geom_cartogram(data=world, map=world,
aes(x=long, y=lat, map_id=region))
gg <- gg + coord_proj("+proj=wintri")
gg
rlang::last_error()
world <- ggplot2::map_data("world")
world <- world[world$region != "Antarctica",]
gg <- ggplot()
gg <- gg + geom_cartogram(data=world, map=world,
aes(x=long, y=lat, map_id=region))
gg
library(ggplot2)
library(gridExtra)
library(ggalt)
library(scales)
set.seed(1492)
dat <- data.frame(x=c(1:10, 1:10, 1:10),
y=c(sample(15:30, 10), 2*sample(15:30, 10), 3*sample(15:30, 10)),
group=factor(c(rep(1, 10), rep(2, 10), rep(3, 10)))
)
View(dat)
ggplot(dat, aes(x, y, group=group, color=group)) +
geom_point() +
geom_line()
ggplot(dat, aes(x, y, group=group, color=factor(group))) +
geom_point() +
geom_line() +
geom_smooth(se=FALSE, linetype="dashed", size=0.5)
ggplot(dat, aes(x, y, group=group, color=factor(group))) +
geom_point(color="black") +
geom_smooth(se=FALSE, linetype="dashed", size=0.5) +
geom_xspline(size=0.5)
ggplot(dat, aes(x, y, group=group, color=factor(group))) +
geom_point(color="black") +
geom_xspline(size=0.5)
x <- -20:20
y <- -20:20
z_val <- function(x, y) {  sqrt(x ^ 2 + y ^ 2)}
z<-outer(x, y, z_val)
persp(x, y, z)
persp(x, y, z, xlab='X Variable', ylab='Y Variable', zlab='Z Variable',
main='3D Plot', col=”orange”, shade=.4)
persp(x, y, z, xlab='X Variable', ylab='Y Variable', zlab='Z Variable',
main='3D Plot', shade=.4)
persp(x, y, z, xlab='X Variable', ylab='Y Variable', zlab='Z Variable',
main='3D Plot', shade=.4, color="Blue")
persp(x, y, z, xlab='X Variable', ylab='Y Variable', zlab='Z Variable',
main='3D Plot', col='red', shade=.4, theta = 30, phi = 15)
