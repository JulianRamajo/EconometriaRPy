distribution.model ="norm")
resid.AAPL_GARCH_fit <- ugarchfit(spec = resid.AAPL_GARCH_spec, data = resid.AAPL)
show(resid.AAPL_GARCH_fit)
hhat <- ts(resid.AAPL_GARCH_fit@fit$sigma^2)
plot.ts(hhat)
plot(resid.AAPL_GARCH_fit)
?getSymbols
View(resid.AAPL_GARCH_fit)
hhat <- zoo(resid.AAPL_GARCH_fit@fit$sigma^2)
plot.zoo(hhat)
getSymbols("GOOGL", auto.assign = TRUE)
getSymbols("MSFT", auto.assign = TRUE)
getSymbols(c('AMZN','FB', 'NFLX'))
rm(list = ls())
getSymbols(c('AAPL','GOOGL','MSFT','AMZN','FB', 'NFLX'))
plot(AAPL)
plot(FB)
View(AAPL)
plot(AAPL$AAPL.Adjusted)
plot(diff(log(AAPL$AAPL.Adjusted)))
View(AAPL)
rm(list = ls())
library(reticulate)
reticulate::repl_python()
# Lectura de librerías
library(tidyverse)
library(zoo)
library(quantmod)
library(dynlm)
library(rugarch)
getSymbols("AAPL")
View(AAPL)
OpenAAPL <- Op(AAPL)   #Open Price
HighAAPL <- Hi(AAPL)    # High price
LowAAPL <- Lo(AAPL)  # Low price
CloseAAPL <- Cl(AAPL)   #Close Price
VolumeAAPL <- Vo(AAPL)   #Volume
AdjCloseAAPL <- Ad(AAPL) # Adjusted close
View(AdjCloseAAPL)
AAPL5y <- last(AAPL,'5 year')
AAPL5ys <- last(AAPL,'5 years')
rm(AAPL5y)
rm(AAPL5ys)
plot(AAPL$AAPL.Adjusted)
plot(diff(log(AAPL$AAPL.Adjusted)))
chartSeries(AAPL, type="line", subset='2015', theme=chartTheme('white'))
chartSeries(AAPL, type="line", theme=chartTheme('white'))
chartSeries(AAPL, type="line", subset='2021', theme=chartTheme('white'))
chartSeries(AAPL, type="line", subset='2021-06::2021-12', theme=chartTheme('white'))
# Modelo AR(1) para los rendimientos
#
rAAPL <- as.zoo(rAAPL)
plot.zoo(rAAPL)
ARreg.AAPL <- dynlm( rAAPL ~ L(rAAPL) )
summary(ARreg.AAPL)
# Cálculo del rendimiento mediante log-diferencias
rAAPL <- diff(log(AAPL$AAPL.Adjusted))
#
# Modelo AR(1) para los rendimientos
#
rAAPL <- as.zoo(rAAPL)
plot.zoo(rAAPL)
ARreg.AAPL <- dynlm( rAAPL ~ L(rAAPL) )
summary(ARreg.AAPL)
# Residuos
resid.AAPL <- resid(ARreg.AAPL)
plot.zoo(ARresid.AAPL)
# Residuos al cuadrado
resid2.AAPL <- resid(ARreg.AAPL)^2
plot.zoo(resid2.AAPL)
Modelo ARCH para los residuos al cuadrado del modelo
#
ARCHreg.AAPL <- dynlm(resid2.AAPL ~ L(resid2.AAPL,1:5))
summary(ARCHreg.AAPL)
#
resid.AAPL_GARCH_spec <-  ugarchspec(
mean.model = list(armaOrder=c(0,0), include.mean = FALSE),
variance.model = list(model="sGARCH", garchOrder=c(1,1)),
distribution.model ="norm")
resid.AAPL_GARCH_fit <- ugarchfit(spec = resid.AAPL_GARCH_spec, data = resid.AAPL)
resid.AAPL_GARCH_fit
show(resid.AAPL_GARCH_fit)
coefficient <-coef(resid.AAPL_GARCH_fit)
volatility <- sigma(resid.AAPL_GARCH_fit)
long.run.variance <- uncvariance(resid.AAPL_GARCH_fit)
coefficient
olatility
volatility
ong.run.variance
long.run.variance
rm(list = ls())
#
library(tidyverse)
library(AER)
library(tseries) # Para obtener datos financieros en internet
library(dynlm)
library(imputeTS)
library(FinTS)
library(fGarch)
library(rugarch)
library(forecast)
library(help="tseries")
#
EURUSD <- get.hist.quote("EURUSD=X", start = "2000-01-01", end = "2021-12-31")
plot(EURUSD)
summary(EURUSD)
EURUSD$Close
autoplot(EURUSD$Close) + facet_free()
plot(EURUSD)
USDJPY <- get.hist.quote("JPY=X", start = "2003-12-01", end = "2021-12-31")
GBPUSD <- get.hist.quote("GBPUSD=X", start = "2003-12-01", end = "2021-12-31")
#
CURR <- merge(EURUSD$Close, USDJPY$Close, GBPUSD$Close)
summary(CURR)
autoplot(CURR)
autoplot(CURR) + facet_free()
statsNA(EURUSD$Close)
ggplot_na_distribution(EURUSD$Close)
ggplot_na_intervals(EURUSD$Close)
statsNA(CURR)
EurUsd <-  na.approx(EURUSD$Close)
statsNA(EurUsd)
autoplot(cbind(EURUSD$Close, EurUsd))
autoplot(EurUsd)
autoplot(EurUsd) + + facet_free()
autoplot(EurUsd) + facet_free()
class(EurUsd)
#
rEurUsd <- 100 * diff(log(EurUsd))
statsNA(rEurUsd)
autoplot(rEurUsd)
summary(rEurUsd)
# Contraste de Engel de efectos ARCH
#
auto.arima(rEurUsd) # Para determinar el modelo estructural
S(rEurUsd_dyn <- dynlm(rEurUsd ~ L(rEurUsd,1:2)))
ArchTest(rEurUsd_dyn$residuals , lags = 1)
#
summary(rEurUsd_dyn <- dynlm(rEurUsd ~ L(rEurUsd,1:2)))
ArchTest(rEurUsd_dyn$residuals , lags = 1)
# Contraste de Engel de efectos ARCH
#
resid2.rEurUsd_ARCH1 <- dynlm(resid2.rEurUsd ~ L(resid2.rEurUsd,1:1))
summary(resid2.rEurUsd_ARCH1)
ArchTest(rEurUsd_AR$residuals , lags = 1)
resid2.rEurUsd_ARCH2 <- dynlm(resid2.rEurUsd ~ L(resid2.rEurUsd,1:2))
summary(resid2.rEurUsd_ARCH2)
ArchTest(rEurUsd_AR$residuals , lags = 2)
resid2.rEurUsd_ARCH1 <- dynlm(resid2.rEurUsd ~ L(resid2.rEurUsd,1:1))
resid2.rEurUsd <- resid(rEurUsd_AR)^2
summary(rEurUsd_AR <- dynlm(rEurUsd ~ L(rEurUsd,1:2)))
resid2.rEurUsd <- resid(rEurUsd_AR)^2
Contraste de Engel de efectos ARCH
#
resid2.rEurUsd_ARCH1 <- dynlm(resid2.rEurUsd ~ L(resid2.rEurUsd,1:1))
summary(resid2.rEurUsd_ARCH1)
ArchTest(rEurUsd_AR$residuals , lags = 1)
resid2.rEurUsd_ARCH2 <- dynlm(resid2.rEurUsd ~ L(resid2.rEurUsd,1:2))
summary(resid2.rEurUsd_ARCH2)
ArchTest(rEurUsd_AR$residuals , lags = 2)
resid2.rEurUsd_ARCH3 <- dynlm(resid2.rEurUsd ~ L(resid2.rEurUsd,1:3))
summary(resid2.rEurUsd_ARCH3)
ArchTest(rEurUsd_AR$residuals , lags = 3)
Librería fGarch
#
rEurUsd_ARMA_GARCH <- garchFit(~ arma(2,0) + garch(1,1), data = rEurUsd, cond.dist = "norm", trace = FALSE)
summary(rEurUsd_ARMA_GARCH)
plot(rEurUsd_ARMA_GARCH)
rEurUsd_ARMA_GARCH <- garchFit(formula = ~ arma(2,0) + garch(1,1), data = rEurUsd,
cond.dist = "norm", trace = FALSE)
summary(rEurUsd_ARMA_GARCH)
rEurUsd_ARMA_GARCH_spec <-  ugarchspec(
mean.model = list(armaOrder=c(2,0), include.mean = TRUE),
variance.model = list(model="sGARCH", garchOrder=c(1,1)),
distribution.model ="norm")
rEurUsd_ARMA_GARCH_fit <- ugarchfit(spec = rEurUsd_ARMA_GARCH_spec, data = rEurUsd)
show(rEurUsd_ARMA_GARCH_fit)
#
library(tidyverse)
library(car)
library(vars)
library(tseries)
library(dynlm)
library(FinTS)
library(rugarch)
library(rmgarch)
#
load("TIPOS_CAMB.RData")
tipos_camb <- ts(monedas[,2:7], frequency=365, start=c(1998, 348))
plot(tipos_camb)
#
reur <- tipos_camb[,"reur"]
rgbp <- tipos_camb[,"rgbp"]
rjpy <- tipos_camb[,"rjpy"]
View(tipos_camb)
EurUsd <-  na.approx(EURUSD$Close)
UsdJpy <-  na.approx(USDJPY$Close)
GbpUsd <-  na.approx(GBPUSD$Close)
#
rEurUsd <- 100 * diff(log(EurUsd))
rUsdJpy <- 100 * diff(log(UsdJpy))
rGbpUsd <- 100 * diff(log(GbpUsd))
VAR_data <- as.matrix(cbind(rEurUsd,rUsdJpy,rGbpUsd))
View(VAR_data)
autoplot(VAR_data) + facet_free()
plot(VAR_data)
class(VAR_data)
VARselect(VAR_data,lag.max = 5, type = "const") # type = c("const", "trend", "both", "none")
VAR2 <-  VAR(VAR_data,p=2)
summary(VAR2)
# IRFs
irf_VAR2 <- irf(VAR2)
plot(irf_VAR2)
plot(fevd_VAR2)
# IRFs
irf_VAR2 <- irf(VAR2)
plot(irf_VAR2)
# FEVDs
fevd_VAR2 <- fevd(VAR2)
plot(fevd_VAR2)
causality(VAR2,cause = c("rGbpUsd","rUsdJpy"))$Granger
grangertest(rEurUsd ~ rGbpUsd)
grangertest(rEurUsd ~ rUsdJpy)
grangertest(as.ts(rEurUsd) ~ as.ts(rGbpUsd))
# Contrastes de causalidad de Granger
causality(VAR2,cause = c("rGbpUsd","rUsdJpy"))$Granger
causality(VAR2,cause = c("rEurUsd","rUsdJpy"))$Granger
causality(VAR2,cause = c("rEurUsd","rGbpUsd"))$Granger
#
grangertest(as.ts(rEurUsd) ~ as.ts(rGbpUsd))
?grangertest
grangertest(as.ts(rEurUsd) ~ as.ts(rGbpUsd), order=2)
#
ArchTest(VAR2$varresult$rEurUsd$residuals , lags = 1)
ArchTest(VAR2$varresult$rGbpUsd$residuals , lags = 1)
ArchTest(VAR2$varresult$rUsdJpy$residuals , lags = 1)
# Modelos AR univariantes con correlación condicional (GARCH-Copula model)
VAR_GARCH_spec_1  <-  ugarchspec(
mean.model = list(armaOrder=c(2,0), include.mean = TRUE),
variance.model = list (garchOrder = c(1,1), model = "sGARCH"))
Multi_spec_1  <-  multispec ( replicate (3 , VAR_GARCH_spec_1) )
Copula_GARCH_spec_1  <-  cgarchspec (Multi_spec_1 , VAR = F)
VAR_GARCH_fit_1 <-  cgarchfit ( Copula_GARCH_spec_1 , data = VAR_data )
show(VAR_GARCH_fit_1)
VAR_GARCH_fit_1@mfit$Rt  # Correlaciones condicionales entre los residuos estandarizados
# Modelo VAR con correlación condicional (GARCH-Copula model)
VAR_GARCH_spec_2  <-  ugarchspec(
variance.model = list (garchOrder =c(1,1), model = "sGARCH"))
Multi_spec_2  <-  multispec ( replicate (3 , VAR_GARCH_spec_2) )
Copula_GARCH_spec_2  <-  cgarchspec (Multi_spec_2, VAR = TRUE, lag = 2)
VAR_GARCH_fit_2 <-  cgarchfit ( Copula_GARCH_spec_2 , data = VAR_data )
show(VAR_GARCH_fit_2)
VAR_GARCH_fit_2@mfit$Rt              # Correlaciones condicionales entre los residuos estandarizados
VAR_GARCH_fit_2@model[["varcoef"]]   # Coeficientes estimados del modelo VAR para la media condicional
VAR_GARCH_fit_2@mfit[["coef"]]       # Coeficientes estimados del modelo GARCH multivariante para la varianza condicional
#
rm(list = ls())
#
library(tidyverse)
library(car)
library(AER)
library(tseries) # Para obtener datos financieros en internet
library(dynlm)
library(imputeTS)
library(FinTS)
library(fGarch)
library(rugarch)
library(vars)
library(rmgarch)
# Para buscar otros tipos de cambio usar la página: https://finance.yahoo.com/currencies
# Para encontrar los principales índices bursátiles usar la página: https://finance.yahoo.com/world-indices
# Y para las principales criptomonedas: https://finance.yahoo.com/cryptocurrencies
EURUSD <- get.hist.quote("EURUSD=X", start = "2003-12-01", end = "2021-12-31")
USDJPY <- get.hist.quote("JPY=X", start = "2003-12-01", end = "2021-12-31")
GBPUSD <- get.hist.quote("GBPUSD=X", start = "2003-12-01", end = "2021-12-31")
CURR <- merge(EURUSD$Close, USDJPY$Close, GBPUSD$Close)
autoplot(CURR) + facet_free()
#
# A partir de ahora se va a modelizar el tipo de cambio euro-dólar EUR/USD (EURUSD=X)
#
plot(EURUSD)
autoplot(EURUSD$Close)
# NAs
statsNA(EURUSD$Close)
ggplot_na_distribution(EURUSD$Close)
ggplot_na_intervals(EURUSD$Close)
EurUsd <-  na.approx(EURUSD$Close) # Reemplaza NAs por valores interpolados linealmente
# (la opción na.spline usa splines cúbicos para la interpolación)
statsNA(EurUsd)
autoplot(EurUsd)
class(EurUsd)
#
# Si se quieren guardar los valores de la variable EurUsd para luego usarlos de nuevo:
#
# write.zoo(EurUsd, "FIN_EURUSD.CSV", index.name = "Index")
#
# EurUsd <- read.zoo("FIN_EURUSD.CSV", header = FALSE, sep = " ", format = "%Y-%m-%d")
#
rEurUsd <- 100 * diff(log(EurUsd))
statsNA(rEurUsd)
autoplot(rEurUsd)
summary(rEurUsd)
#
# Modelo ARIMA para la variable rEurUsd (ARMA al trabajar con log_difs)
#
auto.arima(rEurUsd) # Para determinar el modelo ARIMA más adecuado
#
summary(rEurUsd_AR <- dynlm(rEurUsd ~ L(rEurUsd,1:2)))
resid2.rEurUsd <- resid(rEurUsd_AR)^2
#
# Contraste de Engel de efectos ARCH
#
resid2.rEurUsd_ARCH1 <- dynlm(resid2.rEurUsd ~ L(resid2.rEurUsd,1:1))
summary(resid2.rEurUsd_ARCH1)
ArchTest(rEurUsd_AR$residuals , lags = 1)
resid2.rEurUsd_ARCH2 <- dynlm(resid2.rEurUsd ~ L(resid2.rEurUsd,1:2))
summary(resid2.rEurUsd_ARCH2)
ArchTest(rEurUsd_AR$residuals , lags = 2)
resid2.rEurUsd_ARCH3 <- dynlm(resid2.rEurUsd ~ L(resid2.rEurUsd,1:3))
summary(resid2.rEurUsd_ARCH3)
ArchTest(rEurUsd_AR$residuals , lags = 3)
#
# Modelizaciónn GARCH
#
# Librería fGarch
#
rEurUsd_ARMA_GARCH <- garchFit(formula = ~ arma(2,0) + garch(1,1), data = rEurUsd,
cond.dist = "norm", trace = FALSE)
summary(rEurUsd_ARMA_GARCH)
# plot(rEurUsd_ARMA_GARCH) # Distintas gráficas asociadas al modelo estimado
#
# Librería rugarch
#
rEurUsd_ARMA_GARCH_spec <-  ugarchspec(
mean.model = list(armaOrder=c(2,0), include.mean = TRUE),
variance.model = list(model="sGARCH", garchOrder=c(1,1)),
distribution.model ="norm")
rEurUsd_ARMA_GARCH_fit <- ugarchfit(spec = rEurUsd_ARMA_GARCH_spec, data = rEurUsd)
show(rEurUsd_ARMA_GARCH_fit)
# plot(rEurUsd_ARMA_GARCH_fit)
#
# Modelo VAR para las variables rEurUsd, rUsdJpy y rGbpUsd
#
EurUsd <-  na.approx(EURUSD$Close)
UsdJpy <-  na.approx(USDJPY$Close)
GbpUsd <-  na.approx(GBPUSD$Close)
#
rEurUsd <- 100 * diff(log(EurUsd))
rUsdJpy <- 100 * diff(log(UsdJpy))
rGbpUsd <- 100 * diff(log(GbpUsd))
#
VAR_data <- as.matrix(cbind(rEurUsd,rUsdJpy,rGbpUsd))
#
#
VARselect(VAR_data,lag.max = 5, type = "const") # type = c("const", "trend", "both", "none")
VAR2 <-  VAR(VAR_data,p=2)
summary(VAR2)
#
# IRFs
irf_VAR2 <- irf(VAR2)
plot(irf_VAR2)
plot(fevd_VAR2)
# Contrastes de causalidad de Granger (asociados al modelo VAR)
causality(VAR2,cause = c("rGbpUsd","rUsdJpy"))$Granger
causality(VAR2,cause = c("rEurUsd","rUsdJpy"))$Granger
causality(VAR2,cause = c("rEurUsd","rGbpUsd"))$Granger
# Para contrastes bivariantes usar la función grangertest
# Ejemplo: grangertest(as.ts(rEurUsd) ~ as.ts(rGbpUsd), order=2)
# Modelos VAR con estructura GARCH (multivariante)
#
ArchTest(VAR2$varresult$rEurUsd$residuals , lags = 1)
ArchTest(VAR2$varresult$rGbpUsd$residuals , lags = 1)
ArchTest(VAR2$varresult$rUsdJpy$residuals , lags = 1)
# Modelos AR univariantes con correlación condicional (GARCH-Copula model)
VAR_GARCH_spec_1  <-  ugarchspec(
mean.model = list(armaOrder=c(2,0), include.mean = TRUE),
variance.model = list (garchOrder = c(1,1), model = "sGARCH"))
Multi_spec_1  <-  multispec ( replicate (3 , VAR_GARCH_spec_1) )
Copula_GARCH_spec_1  <-  cgarchspec (Multi_spec_1 , VAR = F)
VAR_GARCH_fit_1 <-  cgarchfit ( Copula_GARCH_spec_1 , data = VAR_data )
show(VAR_GARCH_fit_1)
VAR_GARCH_fit_1@mfit$Rt  # Correlaciones condicionales entre los residuos estandarizados
# Modelo VAR con correlación condicional (GARCH-Copula model)
VAR_GARCH_spec_2  <-  ugarchspec(
variance.model = list (garchOrder =c(1,1), model = "sGARCH"))
Multi_spec_2  <-  multispec ( replicate (3 , VAR_GARCH_spec_2) )
Copula_GARCH_spec_2  <-  cgarchspec (Multi_spec_2, VAR = TRUE, lag = 2)
VAR_GARCH_fit_2 <-  cgarchfit ( Copula_GARCH_spec_2 , data = VAR_data )
show(VAR_GARCH_fit_2)
VAR_GARCH_fit_2@mfit$Rt              # Correlaciones condicionales entre los residuos estandarizados
VAR_GARCH_fit_2@model[["varcoef"]]   # Coeficientes estimados del modelo VAR para la media condicional
VAR_GARCH_fit_2@mfit[["coef"]]       # Coeficientes estimados del modelo GARCH multivariante para la varianza condicional
#
?irf
View(irf_VAR2)
rm(list = ls())
#
library(tidyverse)
library(tidyquant)
library(timetk)
#
#
tq_index_options()
tq_index("SP500")
tq_index("DOW")
# Trabajar con los 4 primeras compañías del SP500
SP500_top4 <- tq_index("SP500") %>%
slice(1:4) %>%
tq_get(get = "stock.prices")
SP500_top4
SP500_top4 %>%  group_by(symbol) %>%
plot_time_series(date, adjusted, .interactive = FALSE)
SP500_top4_prices <- SP500_top4 %>%  select(symbol, date, adjusted)
SP500_top4_spread <- SP500_top4_prices %>%
pivot_wider(names_from = symbol, values_from = adjusted)
#
View(SP500_top4)
SP500_top4 %>%  group_by(symbol) %>%
plot_time_series(date, adjusted, .interactive = FALSE)
SP500_top4_prices <- SP500_top4 %>%  select(symbol, date, adjusted)
SP500_top4_prices <- SP500_top4 %>% select(symbol, date, adjusted)
class(SP500_top4)
SP500_top4_prices <- SP500_top4 %>%
select(symbol, date, adjusted)
SP500_top4_spread <- SP500_top4_prices %>%
pivot_wider(names_from = symbol, values_from = adjusted)
?select
SP500_top4_prices <- SP500_top4 %>% select(symbol)
SP500_top4 %>% select(symbol)
View(SP500_top4)
SP500_top4 %>% select(adjust)
SP500_top4  <- as.tibble(SP500_top4)
SP500_top4  <- as_tibble(SP500_top4)
class(SP500_top4)
SP500_top4_prices <- SP500_top4 %>% select(symbol)
library(tidyverse)
library(tidyquant)
library(timetk)
SP500_top4_prices <- SP500_top4 %>%
select(symbol, date, adjusted)
SP500_top4_prices %>% select(symbol, date, adjusted)
select(SP500_top4, symbol, date, adjusted)
View(SP500_top4)
SP500_top4_spread <- SP500_top4 %>%
pivot_wider(names_from = symbol, values_from = adjusted)
View(SP500_top4_spread)
#
library(tidyverse)
library(tidyquant)
library(timetk)
#
tq_index_options()
tq_exchange_options()
tq_index("SP500")
SP500_top4 <- tq_index("SP500") %>%
slice(1:4) %>%
tq_get(get = "stock.prices")
View(SP500_top4)
SP500_top4
SP500_top4 %>%  group_by(symbol) %>%
plot_time_series(date, adjusted, .interactive = FALSE)
SP500_top4 %>% select(symbol, date, adjusted)
SP500_top4_prices <- SP500_top4 %>% select(symbol, date, adjusted)
SP500_top4_spread <- SP500_top4_prices %>%
pivot_wider(names_from = symbol, values_from = adjusted)
View(SP500_top4_prices)
View(SP500_top4_spread)
#
library(TSstudio)
ts_plot(SP500_top5_spread, title = "Top 4 Stock Prices in SP500", Ytitle = "Index")
#
class(SP500_top4_spread)
rm(SP500_top4_spread)
# Agrupación de series temporales de precios
SP500_top4_ts <- SP500_top4_prices %>% pivot_wider(names_from = symbol, values_from = adjusted)
#
library(TSstudio)
ts_plot(SP500_top4_ts, title = "Top 4 Stock Prices in SP500", Ytitle = "Index")
#
View(SP500_top4_ts)
tq_exchange_options()
tq_exchange("NASDAQ")
tq_get_options()
SP500 <- tq_index("SP500")
View(SP500)
NASDAQ <-  tq_exchange("NASDAQ")
View(NASDAQ)
# Acciones de Apple
TSLA_price  <- tq_get("AAPL", get = "stock.prices")
TSLA_price
# Acciones de Apple
TSLA_price  <- tq_get("TSLA", get = "stock.prices")
TSLA_price
View(TSLA_price)
TSLA_price %>% plot_time_series(date, adjusted, .interactive = FALSE) # librería timetk
# Índice de producción industrial (IPI) de España (desestacionalizado)
IPI_ESP <- tq_get("ESPPROINDMISMEI", get = "economic.data")
IPI_ESP
IPI_ESP %>% plot_time_series(date, price, .interactive = FALSE) # Tendencia
View(IPI_ESP)
# Índice de producción industrial (IPI) de España (desestacionalizado)
IPI_ESP <- tq_get("ESPPROINDMISMEI", get = "economic.data", from = " 1965-01-01")
IPI_ESP
# Tendencia
IPI_ESP %>% plot_time_series(date, price, .interactive = FALSE)
# Valores atípicos
IPI_ESP %>% plot_anomaly_diagnostics(date, price, .facet_ncol = 3, .interactive = FALSE)
# Estacionalidad
IPI_ESP %>% plot_seasonal_diagnostics(date, price, .interactive = FALSE)
#
View(IPI_ESP)
View(TSLA_price)
