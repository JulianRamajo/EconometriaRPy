UE
class(UE)
#
EXP_ESP$D1986 <- as.numeric(UE)-1
EXP_ESP$D1986
class(EXP_ESP$D1986)
#
View(EXP_ESP)
#
EXP_ESP_ts <- ts(EXP_ESP[,2:5], start=c(1970), end = c(1997), frequency = 1)
plot(EXP_ESP_ts)
# Ecuación de exportaciones (1970-1997)
#
lm_X_ESP <- lm(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts)
summary(lm_X_ESP)
#
scatterplot(log(XGS) ~ log(WGDP)| D1986, data=EXP_ESP_ts, smooth=FALSE, boxplots=FALSE, ylab="Relación parcial Exportaciones/PIB mundial (logs)")
scatterplot(log(XGS) ~ log(REER)| D1986, data=EXP_ESP_ts, smooth=FALSE, boxplots=FALSE, ylab="Relación parcial Exportaciones/Tipo de cambio (logs)")
#
# Ecuación de exportaciones (1970-1997)
#
scatterplot(log(XGS) ~ log(WGDP)| UE, data=EXP_ESP_ts, smooth=FALSE, boxplots=FALSE, ylab="Relación parcial Exportaciones/PIB mundial (logs)")
scatterplot(log(XGS) ~ log(REER)| UE, data=EXP_ESP_ts, smooth=FALSE, boxplots=FALSE, ylab="Relación parcial Exportaciones/Tipo de cambio (logs)")
#
# ¿Existe diferenciación por períodos?
#
# Test de Chow de cambio estructural
#
#  Cálculo manual
SRCT <- sum(residuals(lm_X_ESP)^2)
SRCT
T <- nobs(lm_X_ESP)
T
K <- T -df.residual(lm_X_ESP)
K
# PreUE
preUE <- window(EXP_ESP_ts, start=1970, end = 1985)
lm_X_ESP_preUE <- lm(log(XGS) ~ log(WGDP) + log(REER) , data = preUE)
S(lm_X_ESP_preUE)
SRC1 <- sum(residuals(lm_X_ESP_preUE)^2)
SRC1
T1 <- nobs(lm_X_ESP_preUE)
T1
# PostUE
postUE <- window(EXP_ESP_ts, start=1986, end = 1997)
lm_X_ESP_postUE <- lm(log(XGS) ~ log(WGDP) + log(REER) , data = postUE)
S(lm_X_ESP_postUE)
SRC2 <- sum(residuals(lm_X_ESP_postUE)^2)
SRC2
T2 <- nobs(lm_X_ESP_postUE)
T2
#
CHOW=((SRCT-(SRC1+SRC2))/K)/((SRC1+SRC2)/(T-2*K))
CHOW
pval <-  1-pf(CHOW,K,(T-2*K))
pval
# Comparación de parámetros
compareCoefs(lm_X_ESP_preUE,lm_X_ESP_postUE)
# Método 1
summary(lm_X_EXP_int <- lm(log(XGS) ~ log(WGDP) + log(REER) + D1986/(log(WGDP) + log(REER)), data = EXP_ESP_ts))
anova(lm_X_EXP, lm_X_EXP_int)
anova(lm_X_ESP, lm_X_EXP_int)
Regresión diferenciada por tramos
#
lm_X_ESP_2 <- lm(log(XGS) ~ (log(WGDP) + log(REER))*D1986, data=EXP_ESP_ts)
S(lm_X_ESP_2)
# Versión alternativa
lm_X_ESP_3 <- lm(log(XGS) ~ (log(WGDP) + log(REER))*UE, data=EXP_ESP_ts)
S(lm_X_ESP_3)
compareCoefs(lm_X_ESP_preUE,lm_X_ESP_postUE)
#
scatterplot(log(XGS) ~ log(WGDP)| D1986, data=EXP_ESP_ts, smooth=FALSE, boxplots=FALSE, ylab="Relación parcial Exportaciones/PIB mundial (logs)")
scatterplot(log(XGS) ~ log(REER)| D1986, data=EXP_ESP_ts, smooth=FALSE, boxplots=FALSE, ylab="Relación parcial Exportaciones/Tipo de cambio (logs)")
#
View(EXP_ESP)
Y1986=match(1986,EXP_ESP$obs)
Y1986
ibrary(strucchange)
sctest(log(XGS) ~ log(WGDP) + log(REER), data=EXP_ESP_ts, type = "Chow", point = T1)
sctest(log(XGS) ~ log(WGDP) + log(REER), data=EXP_ESP_ts, type = "Chow", point = Y1986-1)
# Test de Chow recursivo
#
Fs <- Fstats(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts, from = 0.15, to = 0.85)
# Gráfica de los estadísticos F
plot(Fs, alpha = 0.05)
# Gráfica de los correspondientes P-valores
plot(Fs, pval = TRUE, alpha = 0.05)
#
Fs
View(Fs)
sbtest <- Fstats(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts, from = 0.15, to = 0.85)
sbtest[["formula"]][["index"]]
sbtest[["Fstats"]]
View(sbtest)
Chow_F <- sbtest$Fstats[Y1986-4]
Chow_F
pval <-  1-pf(Chow_F,K,(T-2*K))
pval
pval <-  1-pchisq(Chow_F,sbtest$nreg)
pval
View(sbtest)
Chow_F/K
pval <-  1-pf(Chow_F/K,K,(T-2*K))
pval
Y1986-4
View(lm_X_ESP)
View(Fs)
library(strucchange)
sctest(log(XGS) ~ log(WGDP) + log(REER), data=EXP_ESP_ts, type = "Chow", point = Y1986-1)
library(strucchange)
sctest(lm_X_ESP, type = "Chow", point = Y1986-1)
lm_X_ESP <- lm(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts)
summary(lm_X_ESP)
library(strucchange)
sctest(lm_X_ESP, type = "Chow", point = Y1986-1)
library(strucchange)
sctest(log(XGS) ~ log(WGDP) + log(REER), data=EXP_ESP_ts, type = "Chow", point = Y1986-1)
sctest(sbtest)
sctest(sbtest, type = aveF)
sctest(sbtest, type = "aveF")
sctest(sbtest, type = "expF")
sctest(sbtest, type = "supF")
View(EXP_ESP_ts)
View(EXP_ESP)
EXP_ESP <- read_csv("EXP_ESP.csv")
View(EXP_ESP)
# Dvisión de la muestra preUE (1970-1985) y postUE (1986-1997)
Y1986=match(1986,EXP_ESP$obs)
Y1986
#
UE <- factor(c(rep(0, 16), rep(1, 12)))
UE
class(UE)
#
EXP_ESP$D1986 <- as.numeric(UE)-1
EXP_ESP$D1986
class(EXP_ESP$D1986)
#
EXP_ESP_ts <- ts(EXP_ESP[,2:5], start=c(1970), end = c(1997), frequency = 1)
plot(EXP_ESP_ts)
View(EXP_ESP_ts)
View(EXP_ESP)
# Test CUSUM (Brown, Durbin y Evans, 1975)
plot(efp(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts))
plot(efp(lm_X_ESP, data=EXP_ESP_ts, type="ME", h=0.2), functional = NULL)
# MCO recursivos
plot(efp(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts), type="ME", h=0.2, functional = NULL )
plot(efp(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts,type="ME", h=0.2))
plot(efp(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts,type="ME", h=0.2), functional = NULL)
plot(efp(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts,type="ME", h=0.1), functional = NULL)
plot(efp(log(XGS) ~ log(WGDP) + log(REER), data = EXP_ESP_ts,type="ME", h=0.15), functional = NULL)
?rm
rm(list = ls())
#
library(tidyverse)
#
SAL_ESP <- read_csv("SAL_ESP.csv")
View(SAL_ESP)
str(SAL_ESP)
View(SAL_ESP)
#
SAL_ESP_ts <- ts(SAL_ESP[,2:5], start=c(1996,1), end=c(2014,3), frequency = 4)
plot(SAL_ESP_ts)
#
library(dynlm)
dyn_SAL_0 <- dynlm(RW ~ L(RW) + RP + RYL + U, data=SAL_ESP_ts) # MCO
summary(dyn_SAL_0)
#
library(car)
linearHypothesis(dyn_SAL_0, c("RP=0", "RYL=0"))
#
dyn_SAL <- dynlm(RW ~ L(RW) + U, data=SAL_ESP_ts)
summary(dyn_SAL)
View(SAL_ESP)
View(SAL_ESP_ts)
Y2010Q1=match("2010Q1",SAL_ESP$obs)
Y2010Q1
#
post2010 <- factor(c(rep(0, 56), rep(1, 75-56)))
post2010
class(post2010)
# Método 1 (ANOVA)
summary(dyn_SAL_int <-dynlm(RW ~ L(RW) + U + post2010/(L(RW) + U), data=SAL_ESP_ts))
anova(dyn_SAL, dyn_SAL_int)
# Método 2 (librería structchange)
library(strucchange)
sbtest <- Fstats(dyn_SAL,data=SAL_ESP_ts)
# Estadísticos de Chow recursivos (structural breaks)
sbtest[["formula"]][["index"]]
sbtest[["Fstats"]]
Fs_CHOW <- ts(sbtest$Fstats, start = c(1999,1), frequency=4)
Fs_CHOW
# Test de Chow de cambio estructura en 2010 Q1
Fs_CHOW[45]
1-pchisq(Fs_CHOW[45],sbtest$nreg)
# Test de Chow de cambio estructura en 2010 Q1
Fs_CHOW[56-11] # 15% de 75 = 11
1-pchisq(Fs_CHOW[56-11],sbtest$nreg)
#
# Regresión diferenciada por tramos
#
D2010Q1 <- as.numeric(post2010)-1
D2010Q1
# Ecuación con cambio estructural
dyn_SAL_1a <- dynlm(RW ~ (L(RW) + U)*D2010Q1, data=SAL_ESP_ts) # Método 1
summary(dyn_SAL_1a)
anova(dyn_SAL,dyn_SAL_1a)
#
dyn_SAL_1b <- dynlm(RW ~ post2010/(L(RW) + U), data=SAL_ESP_ts) # Método 2
summary(dyn_SAL_1b)
linearHypothesis(dyn_SAL_1b, c("split1 =0","split0:L(RW)=split1:L(RW)","split0:U=split1:U"))
dyn_SAL_1b <- dynlm(RW ~  L(RW) + U + post2010/(L(RW) + U), data=SAL_ESP_ts) # Método 2
summary(dyn_SAL_1b)
# Ecuación con cambio estructural
dyn_SAL_1a <- dynlm(RW ~ (L(RW) + U)*D2010Q1, data=SAL_ESP_ts) # Método 1
summary(dyn_SAL_1a)
anova(dyn_SAL,dyn_SAL_1a)
dyn_SAL_1 <- dynlm(RW ~ (L(RW) + U)*D2010Q1, data=SAL_ESP_ts) # Método 1
summary(dyn_SAL_1)
anova(dyn_SAL,dyn_SAL_1)
# Normalidad de los errores
hist(dyn_SAL_1$residuals)
library(moments)
skewness(dyn_SAL_1$residuals)
kurtosis(dyn_SAL_1$residuals)
jarque.test(dyn_SAL_1$residuals)
class(dyn_SAL_1$residuals)
jarque.test(as.data.frame(dyn_SAL_1$residuals)
)
jarque.test(dyn_SAL_1$residuals)
jarque.test(as.vector(dyn_SAL_1$residuals))
agostino.test(dyn_SAL_1$residuals)
ascombe.test(dyn_SAL_1$residuals)
anscombe.test(dyn_SAL_1$residuals)
# Normalidad de los errores
hist(dyn_SAL$residuals)
library(moments)
skewness(dyn_SAL$residuals)
agostino.test(dyn_SAL$residuals)
kurtosis(dyn_SAL$residuals)
anscombe.test(dyn_SAL$residuals)
jarque.test(as.vector(dyn_SAL$residuals))
Test de autocorrelación
library(lmtest)
dwtest(dyn_SAL)
library(ecm)
durbinH(dyn_SAL, "L(RW)")
bgtest(dyn_SAL,order = 1)
# Test de Engle (heteroscedasticidad ARCH)
library(FinTS)
ArchTest(dyn_SAL$residuals, lags = 1)
ArchTest(dyn_SAL$residuals, lags = 2)
# Test de Hausman (2 pasos)
Hausman_1 <- dynlm(U ~ L(RW) + L(U), data=SAL_ESP_ts)
summary(Hausman_1)
Hausman_2 <- dynlm(RW ~ L(RW) + U + Hausman_1$fitted.values, data=SAL_ESP_ts)
summary(Hausman_2)
linearHypothesis(Hausman_2, c("Hausman_1$fitted.values=0"))
# Método VI
dyn_SAL_VI <- dynlm(RW ~ L(RW) + Hausman_1$fitted.values, data=SAL_ESP_ts)
summary(dyn_SAL_VI)
compareCoefs(dyn_SAL,dyn_SAL_VI)
#
library(tidyverse)
GASOL_CRUDO <- read_csv("GASOL_CRUDO.csv")
#
library(zoo)
GASOL_CRUDO_ts <- read.zoo(GASOL_CRUDO)
plot(GASOL_CRUDO_ts)
#
# Modelo dinámico para el precio de la gasolina (precio minorista)
#
library(dynlm)
dyn_model <- dynlm (log(PGASOL) ~ D2008JD + time + L(log(PGASOL), 1:2) + L(log(PCRUDO),0:2), data=GASOL_CRUDO_ts)
summary(dyn_model)
#
# Efectos a corto y largo plazo
#
library(nlWaldTest)
nlConfint(dyn_model, c("b[6]","(b[6]+b[7]+b[8])/(1-b[4]-b[5])"))
nlWaldtest(dyn_model, "b[6]")
nlWaldtest(dyn_model, "(b[6]+b[7]+b[8])/(1-b[4]-b[5])")
#
# Contraste de heteroscedasticidad autoregresiva condicional (efectos ARCH)
#
library(FinTS)
summary(dynlm(I(dyn_model$residuals^2) ~ L(I(dyn_model$residuals^2), 1:1)))
ArchTest(dyn_model$residuals, lag = 1)
#
summary(dynlm(I(dyn_model$residuals^2) ~ L(I(dyn_model$residuals^2), 1:2)))
ArchTest(dyn_model$residuals, lag = 2)
#
library(tseries)
resid <- as.zoo(dyn_model$residuals)
plot(resid)
resid.ARCH <- garch(resid,c(0,2), trace=FALSE)
summary(resid.ARCH)
hhat_1 <- as.zoo(resid.ARCH$fitted.values[,1]^2)
plot(hhat_1)
#
library(rugarch)
resid_GARCH_spec <-  ugarchspec(
mean.model = list(armaOrder=c(0,0), include.mean = FALSE),
variance.model = list(model="sGARCH", garchOrder=c(2,0)),
distribution.model ="norm")
resid_GARCH_fit <- ugarchfit(spec = resid_GARCH_spec, data = resid)
show(resid_GARCH_fit)
hhat_2 <- as.zoo(resid_GARCH_fit@fit$sigma^2)
plot.ts(hhat_2) # ts.plot(Resid_GARCH_fit@fit$sigma^2)
plot(resid_GARCH_fit)
ts.plot(Resid_GARCH_fit@fit$sigma^2)
ts.plot(resid_GARCH_fit@fit$sigma^2)
plot.ts(hhat_2)
View(resid_GARCH_fit)
plot(resid_GARCH_fit)[1]
View(resid.ARCH)
View(resid_GARCH_fit)
detach("package:rugarch", unload = TRUE)
rm(list = ls())
#
library(tidyverse)
GASOL_CRUDO <- read_csv("GASOL_CRUDO.csv")
#
library(zoo)
GASOL_CRUDO_ts <- read.zoo(GASOL_CRUDO)
plot(GASOL_CRUDO_ts)
#
# Modelo dinámico para el precio de la gasolina (precio minorista)
#
library(dynlm)
dyn_model <- dynlm (log(PGASOL) ~ D2008JD + time + L(log(PGASOL), 1:2) + L(log(PCRUDO),0:2), data=GASOL_CRUDO_ts)
summary(dyn_model)
#
# Efectos a corto y largo plazo
#
library(nlWaldTest)
nlConfint(dyn_model, c("b[6]","(b[6]+b[7]+b[8])/(1-b[4]-b[5])"))
nlWaldtest(dyn_model, "b[6]")
nlWaldtest(dyn_model, "(b[6]+b[7]+b[8])/(1-b[4]-b[5])")
#
# Contraste de heteroscedasticidad autoregresiva condicional (efectos ARCH)
#
library(FinTS)
summary(dynlm(I(dyn_model$residuals^2) ~ L(I(dyn_model$residuals^2), 1:1)))
ArchTest(dyn_model$residuals, lag = 1)
#
summary(dynlm(I(dyn_model$residuals^2) ~ L(I(dyn_model$residuals^2), 1:2)))
ArchTest(dyn_model$residuals, lag = 2)
#
# Modelo GARCH para los errores del modelo
#
library(tseries)
resid <- as.zoo(dyn_model$residuals)
plot(resid)
resid.ARCH <- garch(resid,c(0,2), trace=FALSE)
summary(resid.ARCH)
hhat_1 <- as.zoo(resid.ARCH$fitted.values[,1]^2)
plot(hhat_1)
#
plot(resid)
plot(resid^2)
#
library(FinTS)
summary(dynlm(I(dyn_model$residuals^2) ~ L(I(dyn_model$residuals^2), 1:1)))
ArchTest(dyn_model$residuals, lag = 1)
#
summary(dynlm(I(dyn_model$residuals^2) ~ L(I(dyn_model$residuals^2), 1:2)))
ArchTest(dyn_model$residuals, lag = 2)
#
library(tseries)
resid.ARCH <- garch(resid,c(0,2), trace=FALSE)
summary(resid.ARCH)
hhat_1 <- as.zoo(resid.ARCH$fitted.values[,1]^2)
plot(hhat_1)
library(garchmodels)
rIBM
rIBM_train <- rIBM
class(rIBM_train)
View(rIBM_train)
model_resid_GAARCH <-garchmodels::garch_reg(mode = "regression",
arch_order = 2,
garch_order = 0,
ma_order = 0,
ar_order = 0) %>%
set_engine("rugarch", mean.model = list(include.mean = FALSE)) %>%
fit(daily_returns ~ date, data = rIBM_train)
View(model_resid_GAARCH)
show(model_resid_GAARCH)
#
library(rugarch)
resid_GARCH_spec <-  ugarchspec(
mean.model = list(armaOrder=c(0,0), include.mean = FALSE),
variance.model = list(model="sGARCH", garchOrder=c(2,0)),
distribution.model ="norm")
resid_GARCH_fit <- ugarchfit(spec = resid_GARCH_spec, data = resid)
show(resid_GARCH_fit)
hhat_2 <- as.zoo(resid_GARCH_fit@fit$sigma^2)
plot.ts(hhat_2) # ts.plot(Resid_GARCH_fit@fit$sigma^2)
plot(resid_GARCH_fit)
model_resid_GAARCH <-garchmodels::garch_reg(mode = "regression",
arch_order = 2,
garch_order = 0,
ma_order = 0,
ar_order = 0) %>%
set_engine("rugarch", mean.model = list(include.mean = FALSE)) %>%
fit(data = resid)
model_resid_GAARCH <-garchmodels::garch_reg(mode = "regression",
arch_order = 2,
garch_order = 0,
ma_order = 0,
ar_order = 0) %>%
set_engine("rugarch", mean.model = list(include.mean = FALSE)) %>%
fit(resid ~ , data = resid)
plot(resid_GARCH_fit, which=1)
plot.ts(hhat_2)
plot(resid_GARCH_fit, which=3)
ts.plot(Resid_GARCH_fit@fit$sigma^2)
ts.plot(resid_GARCH_fit@fit$sigma^2)
rX_longer
plot(rX_longer)
rm(list = ls())
#
library(tidyverse)
library(car)
library(vars)
library(tseries)
library(dynlm)
library(FinTS)
library(rugarch)
library(rmgarch)
#
load("TIPOS_CAMB.RData")
View(monedas)
tipos_camb <- ts(monedas[,2:7], frequency=365, start=c(1998, 348))
plot(tipos_camb)
View(tipos_camb)
View(monedas)
rm(list = ls())
#
library(tidyverse)
library(dynlm)
library(car)
library(lmtest)
library(sandwich)
library(orcutt)
#
TIPOS_ESP <- read_csv("TIPOS_ESP.csv")
View(TIPOS_ESP)
TIPOS_ESP_ts <- ts(TIPOS_ESP, start=c(1982,1), end = c(1990,3), frequency = 4)
plot(TIPOS_ESP_ts)
# Modelo de Klein-Monti (estático)
#
summary(lm_KM <- lm(RL ~ R3M + RD, data=TIPOS_ESP_ts))
#
summary(dynlm_KM_0 <- dynlm(RL ~ R3M + RD, data=TIPOS_ESP_ts)) # Especificaciónn ARDL(0,0,0)
#
resid <-residuals(dynlm_KM_0)
plot(resid)
abline(h=0, lty=2)
# Correlograma de los residuos
#
corr <- acf(resid)
corr$acf[2:10]
Test de Durbin-Watson
#
dwtest(dynlm_KM_0, alternative = "two.sided")
dwtest(dynlm_KM_0, alternative = "greater")
# Test de Breusch-Godfrey
#
bgtest(dynlm_KM_0, order=1, type="Chisq", fill=0)
#
# Corrección de la autocorrelación: MCO corregidos, MCG-AR, modelos dinámicos del tipo ARDL
#
# MCO corregidos: errores estándar robustos, HAC (Newey-West)
#
summary(dynlm_KM_0 <- dynlm(RL ~ R3M + RD, data=TIPOS_ESP_ts), vcov.=vcovHAC(dynlm_KM_0))
#
Mínimos cuadrados generalizados (MCG): errores AR(1)
#
cochrane.orcutt(dynlm_KM_0)
# Modelo dinámico ARDL(1,1,1)
#
summary(dynlm_KM_1 <- dynlm(RL ~ L(RL, 1:1) + L(R3M, 0:1) + L(RD, 0:1), data=TIPOS_ESP_ts))
#
compareCoefs(dynlm_KM_0,dynlm_KM_1)
#
library(nlWaldTest)
# Modelo estático
nlConfint(dynlm_KM_0, c("b[2]","b[3]"))
nlWaldtest(dynlm_KM_0, "b[2]")
nlWaldtest(dynlm_KM_0, "b[3]")
# Modelo dinámico
# Corto plazo
nlConfint(dynlm_KM_0, c("b[3]","b[5]"))
nlWaldtest(dynlm_KM_0, "b[3]")
nlWaldtest(dynlm_KM_0, "b[5]")
# Largo plazo
nlConfint(dyn_model, c("(b[3]+b[4])/(1-b[2])","(b[5]+b[6])/(1-b[2])"))
nlWaldtest(dyn_model, "(b[3]+b[4])/(1-b[2])")
nlWaldtest(dyn_model, "(b[5]+b[6])/(1-b[2])")
#
# Modelo dinámico
# Corto plazo
nlConfint(dynlm_KM_1, c("b[3]","b[5]"))
nlWaldtest(dynlm_KM_1, "b[3]")
nlWaldtest(dynlm_KM_1, "b[5]")
# Largo plazo
nlConfint(dynlm_KM_1, c("(b[3]+b[4])/(1-b[2])","(b[5]+b[6])/(1-b[2])"))
nlWaldtest(dynlm_KM_1, "(b[3]+b[4])/(1-b[2])")
nlWaldtest(dynlm_KM_1, "(b[5]+b[6])/(1-b[2])")
rm(list = ls())
install.packages(c("fs", "Matrix", "ragg", "rbibutils", "systemfonts"))
