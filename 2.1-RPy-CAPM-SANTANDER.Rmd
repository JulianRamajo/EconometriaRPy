---
title: 'Modelo de regresión lineal simple'
author:
  name: Julián Ramajo, ramajo@unex.es
  affiliation: GRADO EN ESTADÍSTICA | ECONOMETRIA (502243)
subtitle: 'Aplicación 2.1 (Estimación MCO y contrastes de hipótesis): Modelo CAPM para las acciones del Banco Santander'
output:
  html_document:
    theme: journal
    highlight: haddock
    toc: yes
    toc_depth: 2
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
---

# Introducción

En esta aplicación se estimará una versión simple del modelo CAPM (https://es.wikipedia.org/wiki/Modelo_de_valoraci%C3%B3n_de_activos_financieros) para el Banco Santander:

$$er\_SAN_{t} = \beta_{1} + \beta_{2}\, er\_IBEX_{t} + e_{t}$$

donde $er\_SAN$ representa el 'exceso de rendimiento' de las acciones del Banco Santander (rentabilidad de las acciones del banco menos rentabilidad de un activo libre de riesgo, las letras del tesoro) y $er\_IBEX$ es el exceso de rendimiento del mercado (representando por el índice IBEX35 de la bolsa española).

# Código R

```{r, message = FALSE, warning = FALSE}
# Lectura de librerías
library(tidyverse)
# Lectura de datos
CAPM_ESP <- read_delim("CAPM_ESP.csv", delim = ";", escape_double = FALSE, trim_ws = TRUE)
head(CAPM_ESP )
tail(CAPM_ESP )
# Transformación de variables
CAPM_ESP$r_SAN = c(NA,100*diff(log(CAPM_ESP$P_SANTANDER)))
CAPM_ESP$r_IBEX = c(NA,100*diff(log(CAPM_ESP$P_IBEX35)))
CAPM_ESP$r_LT1Y = CAPM_ESP$R_LT1Y/12
CAPM_ESP$er_SAN = CAPM_ESP$r_SAN - CAPM_ESP$r_LT1Y
CAPM_ESP$er_IBEX = CAPM_ESP$r_IBEX - CAPM_ESP$r_LT1Y
# Datos en formato de series temporales
ts_CAPM_ESP <- ts(CAPM_ESP, start = c(2001,5), end = c(2018,1), frequency = 12)
# Gráficas
ts.plot(ts_CAPM_ESP[,"P_IBEX35"])
ts.plot(ts_CAPM_ESP[,"P_SANTANDER"])
ts.plot(ts_CAPM_ESP[,"r_SAN"],ts_CAPM_ESP[,"r_IBEX"])
ts.plot(ts_CAPM_ESP[,"r_LT1Y"])
ts.plot(ts_CAPM_ESP[,"er_SAN"],ts_CAPM_ESP[,"er_IBEX"])
# Modelo CAPM para las acciones del Banco Santander 
# (Como ejercicio, repetir los cálculos para Telefónica e Inditex)
CAPM_SANTANDER  <-  lm(er_SAN ~ er_IBEX, data = ts_CAPM_ESP)
summary(CAPM_SANTANDER)
# Intervalos de confianza para los parámetros estructurales del modelo
# Automáticos
confint(CAPM_SANTANDER)
# Manualmente
alpha <- 0.05
df <- df.residual(CAPM_SANTANDER) # grados de libertad
t_c <- qt(1-alpha/2, df)
b1 <- coef(CAPM_SANTANDER)[[1]] # estimación del parámetro beta1
b1
seb1 <- sqrt(vcov(CAPM_SANTANDER)[1,1]) # estimación de la desviación típica de beta1
seb1
inf_b1 <- b1-t_c*seb1 # cota inferior
sup_b1 <- b1+t_c*seb1 # cota superior
inf_b1 ; sup_b1
b2 <- coef(CAPM_SANTANDER)[[2]] # estimación del parámetro beta2
b2
seb2 <- sqrt(vcov(CAPM_SANTANDER)[2,2]) # estimación de la desviación típica de beta2
seb2
inf_b2 <- b2-t_c*seb2 # cota inferior
sup_b2 <- b2+t_c*seb2 # cota superior
inf_b2 ; sup_b2
# Ajuste del modelo (R^2) y ANOVA
s_CAPM_SANTANDER <- summary(CAPM_SANTANDER)
print(s_CAPM_SANTANDER)
names(s_CAPM_SANTANDER)
R2 <- s_CAPM_SANTANDER$r.squared
R2
anova(CAPM_SANTANDER)
# Número de obsevaciones
T <- nobs(CAPM_SANTANDER)
T
# Número de parámetros
K <- T-df
K
# Estadístico F de significación global
F_0 <- (R2/(K-1))/((1-R2)/(T-K))
F_0
# Residuos del modelo
res <- s_CAPM_SANTANDER$residuals
res <- ts(res, start=c(2001,5), end = c(2018,1), frequency = 12)
plot(res)
ehat <- resid(CAPM_SANTANDER)
ebar <- mean(ehat)
sdehat <- sd(ehat)
hist(ehat, col="grey", freq=FALSE, main="", ylab="density", xlab="ehat")
curve(dnorm(x, ebar, sdehat), col=2, add=TRUE, ylab="density", xlab="ehat")
# Contrastes de hipótesis
# beta1=0 versus beta1≠0
# Estadístico t
alpha <- 0.05 # nivel de significación
b1 <- coef(CAPM_SANTANDER)[[1]] # estimación del parámetro beta1
b1
seb1 <- sqrt(vcov(CAPM_SANTANDER)[1,1]) # estimación de la desviación típica de beta1
seb1
c <- 0
df <- df.residual(CAPM_SANTANDER) # grados de libertad
t_0 <- (b1-c)/seb1 # estadístico t
t_0
# Método del valor crítico
t_c <- qt(1-alpha/2, df) # valor crítico
t_c
# Gráfico de la función de densidad de la distribución t de Student, del valor crítico y del estadístico t:
curve(dt(x, df), -5, 5, ylab=" ", xlab="t")
abline(v=c(-t_c, t_c, t_0), col=c("red", "red", "blue"), lty=c(2,2,3))
legend("topleft", legend=c("-t_c", "t_c", "t_0"), col=c("red", "red", "blue"), lty=c(2, 2, 3))
# Método del P-valor
p <- 2*(1-pt(abs(t_0), df))
p
# Gráfico de la función de densidad de la distribución t de Student y del estadístico t_0:
curve(dt(x, df), -5, 5, ylab=" ", xlab="t")
abline(v=c(t_0), col=c("blue"), lty=c(3))
legend("topleft", legend=c("t_0"), col=c("blue"), lty=c(3))
# Estadístico F
library(car)
H_0 <- "(Intercept) = 0"
linearHypothesis(CAPM_SANTANDER, H_0, test="F")
# Gráfico de la función de densidad de la distribución F de Fisher-Snedecor y del estadístico F_0:
F_0 <- linearHypothesis(CAPM_SANTANDER, H_0, test="F")[2,5] # estadístico F
F_0
F_c <- qf(1-alpha, 1, df) # valor crítico
F_c
curve(df(x, 1, df), 0, 5, ylab=" ", xlab="F")
abline(v=c(F_0,F_c), col=c("blue","red"), lty=c(2,3))
legend("topleft", legend=c("F","Fcr"), col=c("blue","red"), lty=c(2,3))
# beta2=1 versus beta2≠1
# Estadístico t
alpha <- 0.05 # nivel de significación
b2 <- coef(CAPM_SANTANDER)[[2]] # estimación del parámetro beta2
b2
seb2 <- sqrt(vcov(CAPM_SANTANDER)[2,2]) # estimación de la desviación típica de beta2
seb2
c <- 1
df <- df.residual(CAPM_SANTANDER) # grados de libertad
t_0 <- (b2-c)/seb2 # estadístico t
t_0
# Método del valor crítico
t_c <- qt(1-alpha/2, df) # valor crítico
t_c
# Gráfico de la función de densidad de la distribución t de Student, del valor crítico y del estadístico t:
curve(dt(x, df), -6, 6, ylab=" ", xlab="t")
abline(v=c(-t_c, t_c, t_0), col=c("red", "red", "blue"), lty=c(2,2,3))
legend("topleft", legend=c("-t_c", "t_c", "t_0"), col=c("red", "red", "blue"), lty=c(2, 2, 3))
# Método del P-valor
p <- 2*(1-pt(abs(t_0), df))
p
# Gráfico de la función de densidad de la distribución t de Student y del estadístico t:
curve(dt(x, df), -6, 6, ylab=" ", xlab="t")
abline(v=c(t_0), col=c("blue"), lty=c(3))
legend("topleft", legend=c("t_0"), col=c("blue"), lty=c(3))
# Estadístico F
H_0 <- "er_IBEX = 1"
linearHypothesis(CAPM_SANTANDER,H_0,test="F")
# Contraste conjunto de la hipótesis beta1=0, beta2=1
H_0 <- c("(Intercept) = 0", "er_IBEX = 1")
linearHypothesis(CAPM_SANTANDER,H_0,test="F")
# Contrastes unilaterales
# beta2≤1 versus beta2>1
c <- 1
alpha <- 0.05
t_0 <- (b2-c)/seb2
t_0
# Método del valor crítico
t_c <- qt(1-alpha, df) # alpha no se divide por 2
t_c
curve(dt(x, df), -6, 6, ylab=" ", xlab="t")
abline(v=c(t_c, t_0), col=c("red", "blue"), lty=c(2, 3))
legend("topleft", legend=c("t_c", "t_0"), col=c("red", "blue"), lty=c(2, 3))
# Método del P-valor
p <- 1-pt(t_0, df)
p
# beta2≥2 versus beta2<2
c <- 2
alpha <- 0.05
t_0 <- (b2-c)/seb2
t_0
# Método del valor crítico
t_c <- qt(alpha, df) # alpha no se divide por 2
t_c
curve(dt(x, df), -20, 20, ylab=" ", xlab="t")
abline(v=c(t_c, t_0), col=c("red", "blue"), lty=c(2, 3))
legend("topleft", legend=c("t_c", "t_0"), col=c("red", "blue"), lty=c(2, 3))
# Método del P-valor
p <- pt(t_0, df)
p
```

# Código Python

```{python, message = FALSE, warning = FALSE}
# Lectura de librerías
import pandas as pd
import numpy as np
import statsmodels.api as sm
import statsmodels.formula.api as smf
import matplotlib.pyplot as plt
import scipy as sp
# Lectura de datos
CAPM_ESP = pd.read_csv('CAPM_ESP.csv', delimiter=';', index_col=0)
CAPM_ESP.head()
CAPM_ESP.tail()
# Transformación de variables
def LogDiff(x):
    x_diff = 100*np.log(x/x.shift(1))
    return x_diff
CAPM_ESP['r_IBEX'] = LogDiff(CAPM_ESP['P_IBEX35'])
CAPM_ESP['r_SAN'] = LogDiff(CAPM_ESP['P_SANTANDER'])
CAPM_ESP['r_LT1Y'] = CAPM_ESP['R_LT1Y']/12
CAPM_ESP['er_IBEX'] = LogDiff(CAPM_ESP['P_IBEX35']) - CAPM_ESP['R_LT1Y']/12
CAPM_ESP['er_SAN'] = LogDiff(CAPM_ESP['P_SANTANDER']) - CAPM_ESP['R_LT1Y']/12
# Gráficas
plt.figure(1)
plt.plot(CAPM_ESP['er_IBEX'], label='Exceso de rendimiento del IBEX35')
plt.plot(CAPM_ESP['er_SAN'], label='Exceso de rendimiento del Banco Santander')
plt.xlabel('Date')
plt.ylabel('%')
plt.title('Variables del modelo CAPM para el Banco Santander')
plt.grid(True)
plt.legend()
plt.show()
plt.figure(2)
plt.scatter(CAPM_ESP['er_IBEX'], CAPM_ESP['er_SAN'])
plt.xlabel('er_IBEX')
plt.ylabel('er_SAN')
plt.title('Exceso de rendimiento de SAN frente a IBEX')
plt.grid(True)
plt.show()
# Modelo CAPM para las acciones del Banco Santander
formula = 'er_SAN ~ er_IBEX'
CAPM_SANTANDER = smf.ols(formula, CAPM_ESP).fit()
print(CAPM_SANTANDER.summary())
# Intervalos de confianza para los parámetros estructurales del modelo
# Automático
CAPM_SANTANDER.conf_int()
# Manualmente
t_c = np.array(sp.stats.t.interval(0.95,CAPM_SANTANDER.df_resid))
CAPM_SANTANDER.params[0]+CAPM_SANTANDER.bse[0]*t_c
CAPM_SANTANDER.params[1]+CAPM_SANTANDER.bse[1]*t_c
# ANOVA
sm.stats.anova_lm(CAPM_SANTANDER)
# Contrastes de hipótesis
# beta1=0 versus beta1≠0
# Estadístico t
t_stat = (CAPM_SANTANDER.params['Intercept']-0)/CAPM_SANTANDER.bse['Intercept']
t_stat, 2*sp.stats.t.cdf(t_stat, CAPM_SANTANDER.df_resid)
# Estadístico F
H_0 = 'Intercept = 0'
F_test = CAPM_SANTANDER.f_test(H_0)
print(F_test)
# beta2=1 versus beta2≠1
# Estadístico t
t_stat = (CAPM_SANTANDER.params['er_IBEX']-1)/CAPM_SANTANDER.bse['er_IBEX']
t_stat, 2*sp.stats.t.cdf(t_stat, CAPM_SANTANDER.df_resid)
# Estadístico F
H_0 = 'er_IBEX = 1'
F_test = CAPM_SANTANDER.f_test(H_0)
print(F_test)
# Contraste conjunto de la hipótesis beta1=0, beta2=1
H_0 = 'Intercept = 0 , er_IBEX = 1'
F_test = CAPM_SANTANDER.f_test(H_0)
print(F_test)
```
