---
engine: knitr
excerpt: ""
draft: false
format: 
  html:
    theme: simplex
    self-contained: true
    max-width: 1920px
    code-fold: show
    code-tools: true
    highlight-style: atom-one-dark
    code-block-bg: "#282c34"
---


```{css, echo = FALSE}
.justify { text-align: justify !important }
```

::: justify
# Aplicación 2.2: Regresiones con datos de series temporales  {.unnumbered}

## Consumo privado en España {.unnumbered}

En esta aplicación se estimará una función de consumo de tipo Keynesiano agregada (para un consumidor representativo), usando datos de series temporales para España del período 1964-2022:

$$C_{t} = \beta_0 + \beta_1  Y_{t} + e_{t}$$

donde $C$ representa el consumo privado (gasto en consumo final de los hogares e ISFLSH, en millones de € constantes de 2015), e $Y$ es la renta (renta disponible bruta de los hogares e ISFLSH, en millones de € constantes de 2015).

Desde el punto de vista técnico, el objetivo principal del ejemplo es la introducción de las principales funciones y librerías especializadas de R y Python para regresiones con series temporales.
:::

## Código R {.unnumbered}

```{r}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
library(tidyverse)
# Lectura de datos
CONS_ESP <- read_csv("data/CONS_ESP_ts.csv")
head(CONS_ESP)
tail(CONS_ESP)
# Asignación del formato de series temporales
# (https://cran.r-project.org/web/views/TimeSeries.html)
# Aquí se usará la clase básica "ts", válida para series temporales 
# regulares (espaciadas de forma homogénea en el tiempo).
# Pueden usarse otras clases más generales, siendo las más usadas:
# "zoo": https://cran.r-project.org/web/packages/zoo/index.html 
# "xts": https://github.com/joshuaulrich/xts
# "tsibble": https://github.com/robjhyndman/fpp3package
# Ver anexo para una demostración sobre el tidyverts, 
# el complemento al tidyverse para el análisis de series temporales.
#
ts_CONS_ESP <- ts(CONS_ESP[,2:3], start=c(1964), end = c(2022))
#
# Estadística descriptiva
summary(ts_CONS_ESP)
# Gráficas
g1 <- ggplot(data = CONS_ESP, aes(x = Date)) +
  geom_line(aes(y = C)) +
  labs(y = "Consumo privado en España (millones €)", x = "Año")
g1
g2 <- ggplot(data = CONS_ESP, aes(x = Date)) +
  geom_line(aes(y = Y)) +
  labs(y = "Renta disponible en España (millones €)", x = "Año")
g2
# Diagrama de puntos con línea de regresión
g3 <- ggplot(CONS_ESP, aes(x = Y, y = C)) + 
               geom_point() +  
               stat_smooth(method = lm) +  
               labs(x = "Renta disponible",y = "Consumo privado")
g3
# Regresión por MCO
KEYNES_model <- lm (formula = C ~ Y, data = ts_CONS_ESP)
summary(KEYNES_model)
```

```{r}
# ANEXO: La  librería fpp3 y el tidyverts' (https://tidyverts.org/)
# La macro-librería `fpp3` contiene varias librerías específicas
# y otras generales, como `tidyverse` y  `lubridate`.
# La clase `tsibble` proporciona una infraestructura de datos para ordenar
# y manipular series temporales. Se pueden encontrar los detalles en las
# páginas webs https://tsibble.tidyverts.org/index.html y
# https://robjhyndman.com/publications/tsibble/.
# Toda la información de la librería fpp3 se encuentra en:
# https://github.com/robjhyndman/fpp3package. 
# El libro de texto que acompaña a esta librería es el siguiente:
# FORECASTING: PRINCIPLES AND PRACTICE -> https://otexts.com/fpp3/.
#
# NOTA:
# Existen otras librerías especializadas en el análisis de series temporales, 
# como `TSstudio` (https://ramikrispin.github.io/TSstudio/),
# `timetk` (https://business-science.github.io/timetk/) o 
# `tsbox`(https://docs.ropensci.org/tsbox/).
#
library(fpp3) 
# Creación del objeto tsibble
CONS_ESP_ts <-  CONS_ESP[,2:3] %>%
  mutate(Year = 1964:2022) %>%
  as_tsibble(index = Year)
# Gráficas individuales
CONS_ESP_ts %>% autoplot(C) +
  ggtitle("Consumo privado en España") +
  ylab("Millones €") + xlab("Año")
CONS_ESP_ts %>% autoplot(Y) +
  ggtitle("Renta disponible en España") +
  ylab("Millones €") + xlab("Año")
# Diagrama de puntos junto con la recta de regresión estimada
CONS_ESP_ts %>%
  ggplot(aes(x=Y, y=C)) +
  ylab("Consumo privado") +
  xlab("Renta disponible") +
  geom_point() +
  geom_smooth(method="lm", se=FALSE)
# Regresión por MCO
CONS_ESP_ts %>%
  model(tslm = TSLM(C ~ Y)) %>%
  report()
```

## Código Python {.unnumbered}

```{python}
#| include: true
#| warning: false
#| message: false

# Lectura de librerías
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf
# Lectura de datos 
# (al introducir la opción index_col se está asignando en este caso
# de forma implícita un formato temporal para el resto de columnas)
CONS_ESP = pd.read_csv("data/CONS_ESP_ts.csv", index_col=0)
# Asignación del formato temporal 
# (https://pandas.pydata.org/docs/user_guide/timeseries.html)
# Un análisis detallado puede encontrarse en la siguiente página web:
# https://jakevdp.github.io/PythonDataScienceHandbook/
# 03.11-working-with-time-series.html
ts_CONS_ESP = pd.read_csv("data/CONS_ESP_ts.csv", 
parse_dates=['Date'], index_col='Date')
ts_CONS_ESP.head()
ts_CONS_ESP.tail()
# Estadística descriptiva
ts_CONS_ESP.describe()
# Gráficas
plt.plot(ts_CONS_ESP["C"])
plt.xlabel("Año")
plt.ylabel("Consumo privado en España (millones €)")
plt.show()
plt.plot(ts_CONS_ESP["Y"])
plt.xlabel("Año")
plt.ylabel("Renta disponible en España (millones €)")
plt.show()
# Diagrama de puntos con línea de regresión
reg = smf.ols(formula = "C ~ Y", data = ts_CONS_ESP)
res = reg.fit()
plt.scatter(ts_CONS_ESP["Y"], ts_CONS_ESP["C"], color = "black")
plt.plot(ts_CONS_ESP["Y"], res.fittedvalues, color = "blue")
plt.xlabel("Renta disponible")
plt.ylabel("Consumo privado")
plt.show()
# Regresión por MCO
model = smf.ols(formula = "C ~ Y", data = ts_CONS_ESP)
KEYNES_model = model.fit()
print(KEYNES_model.summary())
```

```{python}
#| include: true
#| warning: false
#| message: false

# ANEXO: Clases de modelos y funciones específicas de la librería
# `statsmodels` para el análisis de series temporales 
# (https://www.statsmodels.org/stable/tsa.html)
#
from statsmodels.tsa.api import ARDL
endog = ts_CONS_ESP[["C"]]
exog = ts_CONS_ESP[["Y"]]   # exogs = data[["X2", "X3",...]]
model = ARDL(endog, 0, exog, 0) # retardos=0 equivale a mod. estático
KEYNES_ardl_model = model.fit()
print(KEYNES_ardl_model.summary())
```
